#line 20 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
 
/* Notes
 *
   Many libraries incorrectly define macros for functions without also
   providing a function prototype.  The C standard says that function
   macros can be disabled by putting parens around the function name;
   e.g., (getc)(f) overrides the macro and calls the function
   directly.  Similarly you are supposed to be able to #undef macros
   and use the function.  We need to detect this situation and build a
   C stub automatically.

   It would be nice if buildlib did sanity checking, to make sure that
   the extern "C" function prototypes we code by hand match up with
   the actual C declarations.

   Cygwin sys/select.h defines a struct and then a typedef with the
   same name.  Our current scheme for halting repeated definitions
   does not separate typedefs and structs, so the typedef ends up
   undefined.  The current hack is to hand-define it in that special
   case.

   Cyclone does not currently handle long double complex, which is
   needed in <complex.h>.

   On some systems types aren't defined where they should be.  I
   added cpp for this case, but it would be better to do things
   automatically.

   Some systems don't define types at all -- e.g., socklen_t.  In
   such cases we might be able to derive the type from a function
   that uses it; we currently just take a guess.

   Some systems define typedefs with macros -- e.g., socklen_t in
   cygwin.

   [JGM: fixed]
   OS X defines a struct with no members [/usr/include/net/if_var.h]
   and we don't parse it:
        struct tqdummy {
        };
 */

#include <lexing.h>
#include <set.h>
#include <string.h>
#include <hashtable.h>
#include <filename.h>
#include <arg.h>
#include <buffer.h>
#include "absynpp.h"
#include "parse.h"
#include "tc.h"
// #include "toc.h"
#include "tcdecl.h"
#include "cifc.h"
#include "tcutil.h"
#include "binding.h"
#include "specsfile.h"

namespace Lex {
  extern void lex_init(bool use_cyclone_keywords);
}

using Lexing;
using List;
using Core;
using Absyn;

// The string to invoke gcc
// FIX: this should be taken from the cycspecs file as in cyclone.cyc
static const char ?cyclone_cc = "gcc";
static const char ?target_cflags = "";

static int do_setjmp = 0;
static int verbose = 0;
bool noexpand_r = true;

FILE *log_file = NULL;
FILE *cstubs_file = NULL;
FILE *cycstubs_file = NULL;
int count = 0;

int log(const char ?fmt, ... inject parg_t<`r2> ap)
  __attribute__((format(printf,1,2)))
{
  if (log_file == NULL) {
    fprintf(stderr,"Internal error: log file is NULL\n");
    exit(1);
  }
  let x = vfprintf((FILE@)log_file,fmt,ap);
  fflush((FILE@)log_file);
  return x;
}

static string_t *current_source = NULL;
static list_t<stringptr_t> current_args = NULL;
static Set::set_t<stringptr_t> *current_targets = NULL;
static void add_target(stringptr_t<`H,`H> sptr) {
  current_targets = new Set::insert(*current_targets,sptr);
}
/* Forward declarations of lexing functions */
typedef $(stringptr_t,Set::set_t<stringptr_t>) *line_t;
extern line_t line(Lexbuf<`a>);
extern int macroname(Lexbuf<`a>);
extern int args(Lexbuf<`a>);
extern int token(Lexbuf<`a>);
extern int string(Lexbuf<`a>);

FILE *slurp_out = NULL;
extern int slurp(Lexbuf<`a>);
extern int slurp_string(Lexbuf<`a>);
extern int asmtok(Lexbuf<`a>);
extern int asm_string(Lexbuf<`a>);
extern int asm_comment(Lexbuf<`a>);

typedef $(string_t,stringptr_t) *suck_line_t;
extern suck_line_t suck_line(Lexbuf<`a>);
extern int suck_macroname(Lexbuf<`a>);
extern int suck_restofline(Lexbuf<`a>);
string_t current_line = NULL;

/* When $(A,B) is an ifdefined_t, B will be printed if A is NULL
   or A is a defined symbol */
typedef $(string_t<`H>,string_t<`H>) @ifdefined_t;
/* When $(A,B) is a defined_t, then a non-NULL B is the programmer's
   preferred definition of the type A.  Will be checked for
   compatibility with the actual A. */
typedef $(stringptr_t<`H,`H>,stringptr_t<`H>) @userdef_t;

typedef $(string_t,list_t<stringptr_t>,list_t<userdef_t>,list_t<stringptr_t>,
          list_t<ifdefined_t>,list_t<ifdefined_t>,list_t<ifdefined_t>,
          list_t<stringptr_t>) *spec_t;
extern spec_t spec(Lexbuf<`a>);
extern int commands(Lexbuf<`a>);
extern int snarfsymbols(Lexbuf<`a>);
extern int block(Lexbuf<`a>);
extern int block_string(Lexbuf<`a>);
extern int block_comment(Lexbuf<`a>);
string_t current_headerfile = NULL;
list_t<stringptr_t> snarfed_symbols = NULL;
list_t<stringptr_t> current_symbols = NULL;
list_t<userdef_t> current_user_defs = NULL;
list_t<ifdefined_t> current_cstubs = NULL;
list_t<ifdefined_t> current_cycstubs = NULL;
list_t<ifdefined_t> current_hstubs = NULL;
list_t<stringptr_t> current_omit_symbols = NULL;
list_t<stringptr_t> current_cpp = NULL;
struct Buffer::t *specbuf = NULL;
string_t current_symbol = NULL;
bool rename_current_symbol = false;
int braces_to_match = 0;
int parens_to_match = 0;

int numdef = 0;

static list_t<stringptr_t> cppargs = NULL;

string_t user_prefix = "BUILDLIB_sym_";
static stringptr_t<`H> add_user_prefix(stringptr_t<`H> symbol) {
  string_t<`H> s = (string_t)strconcat(user_prefix,*symbol);
  return new s;
}
static string_t<`H> remove_user_prefix(string_t<`H> symbol) {
  unsigned int prefix_len = strlen(user_prefix);
  if (strncmp(symbol,user_prefix,prefix_len) != 0) {
    fprintf(stderr,"Internal error: bad user type name %s\n",symbol);
    return symbol;
  }
  return (string_t)substring(symbol,prefix_len,strlen(symbol)-prefix_len);
}

static void rename_decl(decl_t d) {
  switch (d->r) {
  case &Aggr_d(ad):
    (*ad->name)[1] = new remove_user_prefix(*(*ad->name)[1]);
    break;
  case &Enum_d(ed):
    (*ed->name)[1] = new remove_user_prefix(*(*ed->name)[1]);
    break;
  case &Typedef_d(td):
    (*td->name)[1] = new remove_user_prefix(*(*td->name)[1]);
    break;

  case &Fn_d(_):
  case &Var_d(_):
  case &Region_d(...):
  case &Datatype_d(_):
  case &Let_d(...):
  case &Letv_d(_):
  case &Namespace_d(...):
  case &Using_d(...):
  case &ExternC_d(...):
  case &ExternCinclude_d(...):
  case &Porton_d:
  case &Portoff_d:
  case &Tempeston_d:
  case &Tempestoff_d:
    fprintf(stderr,"Error in .cys file: bad user-defined type definition\n");
    exit(1);
  }
}

using Lexing {

const int lex_base[] = {0,0,75,192,305,310,311,166,312,91,27,384,28,523,637,715,829,325,92,-3,0,-1,-2,-8,-3,1,-2,323,-4,2,166,-5,605,907,312,-6,-8,-4,16,945,-3,1021,29,11,1135,-4,13,1250,223,-14,317,12,-2,216,20,27,29,34,50,49,71,55,66,101,101,100,108,95,370,386,112,104,105,123,126,375,399,112,134,190,381,1365,1480,414,205,213,233,219,224,224,245,498,1594,1709,-9,525,-10,233,253,507,1823,1938,-7,654,684,-11,432,514,516,2015,2092,2169,2250,434,465,531,2325,253,253,253,251,247,257,0,13,4,2406,5,628,2414,2479,660,-4,-3,49,467,6,2440,7,701,2502,2540,793,-28,1162,1167,273,264,267,271,281,286,292,294,-25,752,276,276,287,280,291,305,305,308,304,314,316,324,326,-23,311,312,315,325,377,394,-27,404,408,404,414,423,424,-19,405,427,421,427,438,434,437,454,455,441,437,437,459,461,-21,453,451,444,457,454,470,464,486,489,477,481,472,498,-26,499,502,512,521,532,535,551,570,571,1141,4,592,573,584,577,577,594,599,602,584,600,617,5,20,-16,622,617,608,609,612,630,619,615,621,637,621,636,629,624,648,627,635,641,646,648,664,665,23,51,-18,651,652,656,666,667,681,683,1,53,823,53,765,708,708,716,743,820,799,759,760,788,785,764,766,821,824,827,774,775,1308,798,799,800,801,764,773,788,794,795,850,851,879,-15,826,827,882,884,912,870,871,926,927,928,-12,875,883,938,939,940,887,888,943,944,945,-13,875,874,888,891,894,876,902,936,942,943,998,1000,-17,1278,971,983,980,979,978,973,1002,1005,1006,1004,1018,1372,1038,1039,1038,1053,1482,1397,1056,1058,1048,1049,1047,1060,1596,1052,1053,1051,1064,1601,-7,-8,8,1260,2572,9,1449,2596,2634,1567,1280,-49,1253,-2,1103,-4,1104,1132,1369,1105,1135,1222,1675,1107,2661,2704,1111,1166,1113,1136,2774,1118,1217,-36,-42,-37,2849,1121,-40,1134,-45,-39,-48,2924,2953,1694,1192,1203,1789,2963,2993,1808,1904,3026,3057,3095,1307,1317,3165,3203,1309,1320,1409,1431,1423,1433,-6,-34,1183,3135,-47,-30,-32,-46,-29,-31,-33,1192,3243,1229,1233,1923,1235,1236,1241,1247,1256,1257,1258,1269,1274,3316,3400,-22,2469,1303,-20,-24,-41,-38,-35,1391,3482,2,1297,1298,1305,3565,1342,15,1284,1285,1286,1285,1285,1297,4};
const int lex_backtrk[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,2,-1,8,-1,3,5,-1,-1,6,5,-1,-1,-1,7,6,-1,6,5,2,0,-1,-1,0,2,-1,12,13,-1,13,13,13,13,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,12,2,4,4,-1,0,0,0,2,0,-1,-1,-1,-1,-1,-1,-1,2,2,8,3,5,-1,6,5,-1,-1,6,5,2,8,3,5,-1,6,5,-1,27,27,27,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,23,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,1,9,2,4,-1,5,4,-1,-1,2,-1,48,-1,48,48,48,48,48,48,48,48,5,7,48,48,48,48,0,48,48,-1,-1,-1,0,43,-1,42,-1,-1,-1,9,7,-1,7,7,-1,8,9,-1,-1,9,5,6,5,5,-1,4,4,4,6,6,5,5,-1,-1,-1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,1,-1,-1,-1,2,1,1,-1,-1,-1,-1,-1,-1,-1};
const int lex_default[] = {-1,-1,-1,383,372,143,23,102,23,19,-1,-1,12,31,49,35,36,23,19,0,-1,0,0,0,0,-1,0,-1,0,-1,-1,0,-1,-1,-1,0,0,0,-1,-1,0,-1,42,-1,-1,0,-1,-1,-1,0,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,-1,-1,-1,-1,0,-1,-1,0,106,-1,-1,-1,-1,-1,113,113,113,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,135,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,272,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,449,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,-1,-1,0,-1,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const int lex_trans[] = {0,0,0,0,0,0,0,0,0,0,22,19,28,481,19,28,19,28,36,19,48,48,46,46,48,22,46,0,0,0,0,0,21,271,21,482,21,22,-1,-1,22,-1,-1,48,224,46,236,22,479,479,479,479,479,479,479,479,479,479,31,106,22,237,117,42,261,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,31,262,272,274,479,135,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,474,474,474,474,474,474,474,474,474,474,124,20,77,22,70,57,58,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,59,60,61,62,474,63,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,64,65,132,384,385,384,384,385,133,22,66,67,68,71,72,134,34,34,34,34,34,34,34,34,73,74,384,386,387,75,78,388,389,390,48,48,391,392,48,393,394,395,396,397,397,397,397,397,397,397,397,397,398,79,399,400,401,48,19,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,19,-1,-1,403,402,80,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,373,404,104,374,144,144,24,24,144,136,125,107,107,84,97,107,85,87,28,88,24,29,86,25,375,89,90,144,91,22,26,26,21,21,107,98,99,145,118,119,120,121,122,123,26,35,35,35,35,35,35,35,35,155,148,149,30,30,30,30,30,30,30,30,69,69,150,151,69,76,76,152,153,76,154,81,81,213,199,81,69,69,376,193,69,184,177,69,137,126,146,170,76,76,76,163,164,76,81,165,166,167,27,69,168,31,169,21,83,83,147,171,83,172,173,174,76,116,116,116,116,116,116,116,116,116,116,-1,32,-1,-1,83,-1,22,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,-1,175,-1,-1,116,-1,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,92,92,28,176,92,178,179,180,181,100,100,182,183,100,185,19,107,107,115,115,107,186,115,92,187,108,108,95,95,108,35,95,100,115,115,188,189,115,190,107,191,115,192,36,194,195,196,197,108,198,95,200,201,202,94,203,115,204,205,21,21,21,109,110,109,109,109,109,109,109,109,109,109,109,21,206,207,208,209,210,211,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,212,214,215,216,109,217,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,50,50,96,218,50,219,220,33,33,33,33,33,33,33,33,33,33,103,103,221,222,103,238,50,33,33,33,33,33,33,131,131,131,131,131,131,131,131,51,227,103,225,-1,228,-1,229,226,104,104,230,52,104,231,232,233,234,33,33,33,33,33,33,35,35,35,35,35,35,35,35,104,235,328,275,263,-1,239,-1,43,43,243,244,43,245,246,240,241,247,248,249,53,250,242,251,252,54,55,253,254,255,256,43,56,142,142,142,142,142,142,142,142,257,258,259,260,264,265,44,44,44,44,44,44,44,44,44,44,266,267,268,269,36,270,28,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,94,105,276,277,44,278,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,279,290,45,35,35,35,35,35,35,35,35,156,157,158,280,159,282,283,284,160,285,286,281,287,288,37,273,289,161,162,49,291,292,322,317,311,306,298,38,39,39,39,39,39,39,39,39,39,39,299,300,301,302,303,304,21,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,305,307,308,309,39,310,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,40,105,22,33,33,33,33,33,33,33,33,33,33,312,313,314,315,316,318,31,33,33,33,33,33,33,319,320,321,96,323,324,325,326,327,329,330,331,332,333,334,41,41,41,41,41,41,41,41,41,41,335,33,33,33,33,33,33,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,336,337,338,339,41,340,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,354,41,41,41,41,41,41,41,41,41,41,-1,349,345,346,347,348,21,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,102,350,351,352,41,353,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,46,46,355,356,46,357,222,222,358,367,222,362,363,364,365,366,368,369,370,371,212,472,448,46,439,414,470,359,359,222,154,359,341,341,446,407,341,223,410,47,47,47,47,47,47,47,47,47,47,471,359,413,447,143,409,341,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,411,176,412,442,47,469,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,22,46,46,360,473,46,473,473,342,443,468,382,382,361,183,382,198,262,343,36,405,36,105,344,46,444,445,473,316,341,341,382,382,341,382,382,21,327,49,305,47,47,47,47,47,47,47,47,47,47,237,36,341,36,382,340,21,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,406,465,477,478,47,28,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,22,81,81,293,342,81,-1,294,353,353,21,483,353,484,343,485,295,486,296,35,35,31,487,31,81,488,0,473,0,473,473,353,0,359,359,-1,0,359,0,19,82,82,82,82,82,82,82,82,82,82,473,35,35,31,297,31,359,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,0,0,0,0,82,450,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,31,83,83,358,358,83,102,358,360,381,381,381,381,381,381,381,381,0,361,102,438,438,0,0,83,0,358,0,0,0,0,0,0,0,31,0,0,0,102,0,82,82,82,82,82,82,82,82,82,82,0,102,438,438,0,0,0,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,0,0,0,0,82,0,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,92,92,366,366,92,0,366,371,371,0,0,371,31,31,31,31,31,31,31,31,0,0,-1,92,0,366,0,0,0,0,371,0,0,28,0,0,0,0,35,93,93,93,93,93,93,93,93,93,93,0,0,0,0,0,0,0,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,0,0,0,0,93,0,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,94,95,95,0,440,95,441,441,441,441,441,441,441,441,441,441,0,0,0,0,420,0,420,0,95,421,421,421,421,421,421,421,421,421,421,0,0,0,0,0,93,93,93,93,93,93,93,93,93,93,0,0,0,0,0,0,0,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,0,0,0,0,93,0,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,100,100,0,0,100,421,421,421,421,421,421,421,421,421,421,0,0,0,0,424,0,424,0,100,425,425,425,425,425,425,425,425,425,425,0,0,0,0,0,101,101,101,101,101,101,101,101,101,101,0,0,0,0,0,0,0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,0,0,0,0,101,0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,102,103,103,0,0,103,425,425,425,425,425,425,425,425,425,425,465,0,0,0,0,0,0,0,103,466,466,466,466,466,466,466,466,0,0,0,0,0,0,0,101,101,101,101,101,101,101,101,101,101,0,0,0,0,0,0,0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,0,0,0,0,101,0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,111,111,111,111,111,111,111,111,111,111,111,111,22,0,0,0,0,0,0,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,0,0,0,0,111,0,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,112,111,111,111,111,111,111,111,111,111,111,22,0,0,0,0,0,0,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,0,0,0,0,111,0,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,22,0,0,0,0,0,0,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,-1,0,0,-1,111,0,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,0,0,0,0,112,112,112,112,112,112,112,112,112,112,112,112,114,0,0,0,0,0,0,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,0,0,0,0,112,0,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,116,116,116,116,116,116,116,116,116,116,0,0,0,0,0,0,0,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,28,0,0,127,116,0,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,0,0,28,0,0,138,128,128,128,128,128,128,128,128,130,130,130,130,130,130,130,130,130,130,0,0,0,0,0,0,0,130,130,130,130,130,130,0,0,0,139,139,139,139,139,139,139,139,0,0,0,0,0,0,0,31,0,0,-1,0,465,0,0,130,130,130,130,130,130,467,467,467,467,467,467,467,467,0,129,130,130,130,130,130,130,130,130,130,130,31,0,0,0,0,0,0,130,130,130,130,130,130,141,141,141,141,141,141,141,141,141,141,140,0,0,0,0,0,0,141,141,141,141,141,141,0,0,0,130,130,130,130,130,130,19,0,0,377,0,0,141,141,141,141,141,141,141,141,141,141,0,141,141,141,141,141,141,141,141,141,141,141,141,0,0,0,0,0,0,0,0,0,378,378,378,378,378,378,378,378,0,0,0,0,0,0,0,0,0,141,141,141,141,141,141,0,380,380,380,380,380,380,380,380,380,380,0,0,0,0,0,0,0,380,380,380,380,380,380,0,0,28,0,0,0,0,0,0,0,0,0,0,0,0,380,380,380,380,380,380,380,380,380,380,379,380,380,380,380,380,380,380,380,380,380,380,380,0,0,415,0,426,426,426,426,426,426,426,426,427,427,0,0,0,0,0,0,0,0,0,0,0,417,380,380,380,380,380,380,428,0,0,0,0,0,0,0,0,429,0,0,430,415,0,416,416,416,416,416,416,416,416,416,416,417,0,0,0,0,0,0,428,0,0,0,417,0,0,0,0,429,0,418,430,0,0,0,0,0,0,0,419,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,417,0,0,0,0,0,0,418,0,0,0,0,0,0,0,0,419,408,408,408,408,408,408,408,408,408,408,0,0,0,0,0,0,0,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,0,0,0,0,408,0,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,0,0,0,0,0,0,0,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,0,0,0,0,408,0,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,422,422,422,422,422,422,422,422,422,422,0,0,0,0,0,0,0,0,0,0,0,423,96,0,0,0,0,415,96,416,416,416,416,416,416,416,416,416,416,421,421,421,421,421,421,421,421,421,421,0,417,0,0,423,96,0,0,418,0,0,96,94,0,0,0,0,419,94,0,422,422,422,422,422,422,422,422,422,422,0,0,0,417,0,0,0,0,0,0,418,423,96,0,94,0,0,0,96,419,94,0,0,425,425,425,425,425,425,425,425,425,425,0,0,0,0,0,0,0,0,0,0,423,96,96,0,0,0,0,96,96,415,0,426,426,426,426,426,426,426,426,427,427,0,0,0,0,0,0,0,0,0,0,0,417,0,96,0,0,0,0,436,96,0,0,0,0,0,0,415,437,427,427,427,427,427,427,427,427,427,427,0,0,0,0,0,417,0,0,0,0,0,417,436,0,0,0,0,0,434,0,0,437,0,0,0,0,0,435,0,0,441,441,441,441,441,441,441,441,441,441,0,0,0,417,0,0,0,0,0,0,434,423,96,0,0,0,0,0,96,435,431,431,431,431,431,431,431,431,431,431,0,0,0,0,0,0,0,431,431,431,431,431,431,423,96,0,0,0,0,0,96,0,0,0,0,0,0,0,431,431,431,431,431,431,431,431,431,431,0,431,431,431,431,431,431,431,431,431,431,431,431,0,0,0,451,0,432,0,0,452,0,0,0,0,0,433,0,0,453,453,453,453,453,453,453,453,0,431,431,431,431,431,431,454,0,0,0,0,432,0,0,0,0,0,0,0,0,433,0,0,0,0,0,0,0,0,0,0,0,0,0,0,455,0,0,0,0,456,457,0,0,0,458,0,0,0,0,0,0,0,459,0,0,0,460,0,461,0,462,0,463,464,464,464,464,464,464,464,464,464,464,0,0,0,0,0,0,0,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,0,0,0,0,0,0,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,169,0,0,0,0,0,0,0,0,464,464,464,464,464,464,464,464,464,464,0,0,0,0,0,0,0,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,0,0,0,0,0,0,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,19,0,0,475,0,476,0,474,474,474,474,474,474,474,474,474,474,0,0,0,0,0,0,0,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,0,0,0,0,474,0,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,480,0,0,0,0,0,0,0,479,479,479,479,479,479,479,479,479,479,0,0,0,0,0,0,0,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,0,0,0,0,479,0,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
const int lex_check[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,25,29,0,125,127,136,138,374,377,43,43,46,46,43,481,46,-1,-1,-1,-1,-1,123,270,475,0,488,10,12,42,10,12,42,43,223,46,235,20,1,1,1,1,1,1,1,1,1,1,38,51,124,236,10,38,260,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,134,261,271,273,1,134,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,9,18,54,46,55,56,57,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,58,59,60,61,2,62,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,63,64,7,3,3,3,3,3,7,7,65,66,67,70,71,7,30,30,30,30,30,30,30,30,72,73,3,3,3,74,77,3,3,3,48,48,3,3,48,3,3,3,3,3,3,3,3,3,3,3,3,3,3,78,3,3,3,48,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,10,12,42,3,3,79,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,84,4,5,5,6,8,5,6,8,50,50,53,85,50,53,86,27,87,17,27,53,17,4,88,89,5,90,5,6,8,9,18,50,97,98,5,117,118,119,120,121,122,17,34,34,34,34,34,34,34,34,146,147,148,27,27,27,27,27,27,27,27,68,68,149,150,68,75,75,151,152,75,153,80,80,156,157,80,69,69,4,158,69,159,160,68,6,8,5,161,75,76,76,162,163,76,80,164,165,166,17,69,167,27,168,7,83,83,5,170,83,171,172,173,76,11,11,11,11,11,11,11,11,11,11,106,27,113,106,83,113,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,114,174,135,114,11,135,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,91,91,69,175,91,177,178,179,180,99,99,181,182,99,184,76,107,107,108,108,107,185,108,91,186,13,13,95,95,13,83,95,99,115,115,187,188,115,189,107,190,108,191,192,193,194,195,196,13,197,95,199,200,201,4,202,115,203,204,5,6,8,13,13,13,13,13,13,13,13,13,13,13,13,17,205,206,207,208,209,210,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,211,213,214,215,13,216,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,95,217,14,218,219,32,32,32,32,32,32,32,32,32,32,103,103,220,221,103,225,14,32,32,32,32,32,32,128,128,128,128,128,128,128,128,14,226,103,224,106,227,113,228,224,104,104,229,14,104,230,231,232,233,32,32,32,32,32,32,131,131,131,131,131,131,131,131,104,234,239,240,241,114,238,135,15,15,242,243,15,244,245,238,238,246,247,248,14,249,238,250,251,14,14,252,253,254,255,15,14,139,139,139,139,139,139,139,139,256,257,258,259,263,264,15,15,15,15,15,15,15,15,15,15,265,266,267,268,103,269,13,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,274,104,275,276,15,277,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,278,280,15,142,142,142,142,142,142,142,142,155,155,155,279,155,281,282,283,155,284,285,279,286,287,16,272,288,155,155,289,290,291,293,294,295,296,297,16,16,16,16,16,16,16,16,16,16,16,298,299,300,301,302,303,14,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,304,306,307,308,16,309,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,310,16,33,33,33,33,33,33,33,33,33,33,311,312,313,314,315,317,15,33,33,33,33,33,33,318,319,320,321,322,323,324,325,326,328,329,330,331,332,333,39,39,39,39,39,39,39,39,39,39,334,33,33,33,33,33,33,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,335,336,337,338,39,339,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,342,41,41,41,41,41,41,41,41,41,41,272,343,344,345,346,347,16,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,348,349,350,351,41,352,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,44,44,354,355,44,356,222,222,357,360,222,361,362,363,364,365,367,368,369,370,386,388,391,44,395,398,389,144,144,222,400,144,145,145,392,403,145,222,409,44,44,44,44,44,44,44,44,44,44,389,144,411,392,401,401,145,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,399,399,399,440,44,449,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,47,47,144,384,47,384,384,145,393,451,375,375,144,452,375,454,455,145,418,404,419,456,145,47,393,393,384,457,341,341,382,382,341,375,382,375,458,459,460,47,47,47,47,47,47,47,47,47,47,461,418,341,419,382,462,382,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,404,467,476,477,47,478,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,81,81,292,341,81,390,292,353,353,480,482,353,483,341,484,292,485,292,428,429,432,486,433,81,487,-1,473,-1,473,473,353,-1,359,359,390,-1,359,-1,353,81,81,81,81,81,81,81,81,81,81,473,428,429,432,292,433,359,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,-1,-1,-1,-1,81,390,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,358,358,82,434,358,359,378,378,378,378,378,378,378,378,-1,359,435,436,437,-1,-1,82,-1,358,-1,-1,-1,-1,-1,-1,-1,358,-1,-1,-1,434,-1,82,82,82,82,82,82,82,82,82,82,-1,435,436,437,-1,-1,-1,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,-1,-1,-1,-1,82,-1,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,92,92,366,366,92,-1,366,371,371,-1,-1,371,381,381,381,381,381,381,381,381,-1,-1,390,92,-1,366,-1,-1,-1,-1,371,-1,-1,366,-1,-1,-1,-1,371,92,92,92,92,92,92,92,92,92,92,-1,-1,-1,-1,-1,-1,-1,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,-1,-1,-1,-1,92,-1,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,93,93,-1,394,93,394,394,394,394,394,394,394,394,394,394,-1,-1,-1,-1,417,-1,417,-1,93,417,417,417,417,417,417,417,417,417,417,-1,-1,-1,-1,-1,93,93,93,93,93,93,93,93,93,93,-1,-1,-1,-1,-1,-1,-1,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,-1,-1,-1,-1,93,-1,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,100,100,-1,-1,100,420,420,420,420,420,420,420,420,420,420,-1,-1,-1,-1,423,-1,423,-1,100,423,423,423,423,423,423,423,423,423,423,-1,-1,-1,-1,-1,100,100,100,100,100,100,100,100,100,100,-1,-1,-1,-1,-1,-1,-1,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,-1,-1,-1,-1,100,-1,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,101,101,-1,-1,101,424,424,424,424,424,424,424,424,424,424,453,-1,-1,-1,-1,-1,-1,-1,101,453,453,453,453,453,453,453,453,-1,-1,-1,-1,-1,-1,-1,101,101,101,101,101,101,101,101,101,101,-1,-1,-1,-1,-1,-1,-1,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,-1,-1,-1,-1,101,-1,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,109,109,109,109,109,109,109,109,109,109,109,109,109,-1,-1,-1,-1,-1,-1,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,-1,-1,-1,-1,109,-1,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,110,110,110,110,110,110,110,110,110,110,110,110,110,-1,-1,-1,-1,-1,-1,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,-1,-1,-1,-1,110,-1,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,111,111,111,111,111,111,111,111,111,111,111,111,111,-1,-1,-1,-1,-1,-1,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,112,-1,-1,112,111,-1,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,-1,-1,-1,-1,112,112,112,112,112,112,112,112,112,112,112,112,112,-1,-1,-1,-1,-1,-1,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,-1,-1,-1,-1,112,-1,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,116,116,116,116,116,116,116,116,116,116,-1,-1,-1,-1,-1,-1,-1,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,126,-1,-1,126,116,-1,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,-1,-1,137,-1,-1,137,126,126,126,126,126,126,126,126,129,129,129,129,129,129,129,129,129,129,-1,-1,-1,-1,-1,-1,-1,129,129,129,129,129,129,-1,-1,-1,137,137,137,137,137,137,137,137,-1,-1,-1,-1,-1,-1,-1,126,-1,-1,112,-1,466,-1,-1,129,129,129,129,129,129,466,466,466,466,466,466,466,466,-1,126,130,130,130,130,130,130,130,130,130,130,137,-1,-1,-1,-1,-1,-1,130,130,130,130,130,130,140,140,140,140,140,140,140,140,140,140,137,-1,-1,-1,-1,-1,-1,140,140,140,140,140,140,-1,-1,-1,130,130,130,130,130,130,376,-1,-1,376,-1,-1,141,141,141,141,141,141,141,141,141,141,-1,140,140,140,140,140,140,141,141,141,141,141,141,-1,-1,-1,-1,-1,-1,-1,-1,-1,376,376,376,376,376,376,376,376,-1,-1,-1,-1,-1,-1,-1,-1,-1,141,141,141,141,141,141,-1,379,379,379,379,379,379,379,379,379,379,-1,-1,-1,-1,-1,-1,-1,379,379,379,379,379,379,-1,-1,376,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,380,380,380,380,380,380,380,380,380,380,376,379,379,379,379,379,379,380,380,380,380,380,380,-1,-1,396,-1,396,396,396,396,396,396,396,396,396,396,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,396,380,380,380,380,380,380,396,-1,-1,-1,-1,-1,-1,-1,-1,396,-1,-1,396,397,-1,397,397,397,397,397,397,397,397,397,397,396,-1,-1,-1,-1,-1,-1,396,-1,-1,-1,397,-1,-1,-1,-1,396,-1,397,396,-1,-1,-1,-1,-1,-1,-1,397,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,397,-1,-1,-1,-1,-1,-1,397,-1,-1,-1,-1,-1,-1,-1,-1,397,402,402,402,402,402,402,402,402,402,402,-1,-1,-1,-1,-1,-1,-1,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,-1,-1,-1,-1,402,-1,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,408,408,408,408,408,408,408,408,408,408,-1,-1,-1,-1,-1,-1,-1,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,-1,-1,-1,-1,408,-1,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,415,415,415,415,415,415,415,415,415,415,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,415,415,-1,-1,-1,-1,416,415,416,416,416,416,416,416,416,416,416,416,421,421,421,421,421,421,421,421,421,421,-1,416,-1,-1,415,415,-1,-1,416,-1,-1,415,421,-1,-1,-1,-1,416,421,-1,422,422,422,422,422,422,422,422,422,422,-1,-1,-1,416,-1,-1,-1,-1,-1,-1,416,422,422,-1,421,-1,-1,-1,422,416,421,-1,-1,425,425,425,425,425,425,425,425,425,425,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,422,422,425,-1,-1,-1,-1,422,425,426,-1,426,426,426,426,426,426,426,426,426,426,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,426,-1,425,-1,-1,-1,-1,426,425,-1,-1,-1,-1,-1,-1,427,426,427,427,427,427,427,427,427,427,427,427,-1,-1,-1,-1,-1,426,-1,-1,-1,-1,-1,427,426,-1,-1,-1,-1,-1,427,-1,-1,426,-1,-1,-1,-1,-1,427,-1,-1,441,441,441,441,441,441,441,441,441,441,-1,-1,-1,427,-1,-1,-1,-1,-1,-1,427,441,441,-1,-1,-1,-1,-1,441,427,430,430,430,430,430,430,430,430,430,430,-1,-1,-1,-1,-1,-1,-1,430,430,430,430,430,430,441,441,-1,-1,-1,-1,-1,441,-1,-1,-1,-1,-1,-1,-1,431,431,431,431,431,431,431,431,431,431,-1,430,430,430,430,430,430,431,431,431,431,431,431,-1,-1,-1,450,-1,431,-1,-1,450,-1,-1,-1,-1,-1,431,-1,-1,450,450,450,450,450,450,450,450,-1,431,431,431,431,431,431,450,-1,-1,-1,-1,431,-1,-1,-1,-1,-1,-1,-1,-1,431,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,450,-1,-1,-1,-1,450,450,-1,-1,-1,450,-1,-1,-1,-1,-1,-1,-1,450,-1,-1,-1,450,-1,450,-1,450,-1,450,463,463,463,463,463,463,463,463,463,463,-1,-1,-1,-1,-1,-1,-1,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,-1,-1,-1,-1,-1,-1,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,463,464,-1,-1,-1,-1,-1,-1,-1,-1,464,464,464,464,464,464,464,464,464,464,-1,-1,-1,-1,-1,-1,-1,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,-1,-1,-1,-1,-1,-1,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,474,-1,-1,474,-1,474,-1,474,474,474,474,474,474,474,474,474,474,-1,-1,-1,-1,-1,-1,-1,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,-1,-1,-1,-1,474,-1,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,474,479,-1,-1,-1,-1,-1,-1,-1,479,479,479,479,479,479,479,479,479,479,-1,-1,-1,-1,-1,-1,-1,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,-1,-1,-1,-1,479,-1,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,479,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
     int lex_engine(int start_state, Lexbuf<`a> lbuf) {

       int state, base, backtrk;
       int c;
       state = start_state;

       if (state >= 0) {
	 lbuf->lex_last_pos = lbuf->lex_start_pos = lbuf->lex_curr_pos;
	 lbuf->lex_last_action = -1;
       } else {
	 state = -state-1;
       }
       while (true) {
	 base = lex_base[state];
	 if (base < 0) return -base-1;
	 backtrk = lex_backtrk[state];
	 if (backtrk >= 0) {
	   lbuf->lex_last_pos    = lbuf->lex_curr_pos;
	   lbuf->lex_last_action = backtrk;
	 }
	 if (lbuf->lex_curr_pos >= lbuf->lex_buffer_len) {
	   if (!lbuf->lex_eof_reached)
	     return -state-1;
	   else
	     c = 256;
	 } else {
	   c = (int) (lbuf->lex_buffer[lbuf->lex_curr_pos++]);
	   if (c==EOF) c=256;
	 }
	 if (lex_check[base+c]==state)
	   state = lex_trans[base+c];
	 else
	   state = lex_default[state];
	 if (state < 0) {
	   lbuf->lex_curr_pos = lbuf->lex_last_pos;
	   if (lbuf->lex_last_action == -1)
	     throw new Error("empty token");
	   else {
	     return lbuf->lex_last_action;
	   }
	 } else {
	   if (c == 256) lbuf->lex_eof_reached = false;
	 }
       }
  }
line_t line_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 232 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
 
  log("Count = %d\n", count++); 
   macroname(lexbuf);
  for (; current_args != NULL; current_args = current_args->tl) {
    current_targets = new Set::delete(*current_targets,current_args->hd);
  }
  /* The cast is needed so the return type matches */
  return new $((_ @)current_source,*current_targets);
case 1: 
#line 242 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return line(lexbuf); 
case 2: 
#line 244 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return NULL;  default:
   lexbuf->refill_buff(lexbuf);
   return line_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
line_t line(Lexbuf<`a> lexbuf) { return line_rec(lexbuf,0); }
int macroname_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 248 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  current_source = new (string_t)substring(lexeme(lexbuf), 0,
                                          lexeme_end(lexbuf)-lexeme_start(lexbuf)-2);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  token(lexbuf);
  return 0;

case 1: 
#line 256 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  current_source = new (string_t)substring(lexeme(lexbuf), 0,
                                          lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  args(lexbuf);
  return 0;

case 2: 
#line 264 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  current_source = new (string_t)lexeme(lexbuf);
  current_args = NULL;
  current_targets = new Set::empty(strptrcmp);
  token(lexbuf);
  return 0;
 default:
   lexbuf->refill_buff(lexbuf);
   return macroname_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int macroname(Lexbuf<`a> lexbuf) { return macroname_rec(lexbuf,1); }
int args_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 273 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-2);
  current_args = new List(a,current_args);
  return args(lexbuf);

case 1: 
#line 279 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = new List(a,current_args);
  return args(lexbuf);

case 2: 
#line 285 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = new List(a,current_args);
  return token(lexbuf);

case 3: 
#line 291 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let a = new (string_t)substring(lexeme(lexbuf), 0,
                                  lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_args = new List(a,current_args);
  return token(lexbuf);
 default:
   lexbuf->refill_buff(lexbuf);
   return args_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int args(Lexbuf<`a> lexbuf) { return args_rec(lexbuf,2); }
int token_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 300 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  add_target(new (string_t)lexeme(lexbuf)); return token(lexbuf); 
case 1: 
#line 303 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 2: 
#line 306 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return  token(lexbuf); 
case 3: 
#line 309 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  string(lexbuf); return token(lexbuf);
case 4: 
#line 312 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 5: 
#line 314 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 6: 
#line 316 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 7: 
#line 318 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 8: 
#line 321 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 9: 
#line 324 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 10: 
#line 327 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 11: 
#line 329 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 12: 
#line 331 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 13: 
#line 333 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 14: 
#line 335 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 15: 
#line 337 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 16: 
#line 339 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 17: 
#line 341 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 18: 
#line 343 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 19: 
#line 345 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 20: 
#line 347 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 21: 
#line 349 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 22: 
#line 351 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 23: 
#line 353 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 24: 
#line 356 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 25: 
#line 358 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 26: 
#line 360 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 27: 
#line 362 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 28: 
#line 364 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 29: 
#line 366 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 30: 
#line 368 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 31: 
#line 370 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 32: 
#line 372 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 33: 
#line 374 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 34: 
#line 376 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 35: 
#line 378 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 36: 
#line 380 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 37: 
#line 382 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 38: 
#line 384 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 39: 
#line 386 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 40: 
#line 388 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 41: 
#line 390 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 42: 
#line 392 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 43: 
#line 394 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 44: 
#line 396 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 45: 
#line 398 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 46: 
#line 400 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 47: 
#line 402 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf); 
case 48: 
#line 405 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return token(lexbuf);  default:
   lexbuf->refill_buff(lexbuf);
   return token_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int token(Lexbuf<`a> lexbuf) { return token_rec(lexbuf,3); }
int string_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 410 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return string(lexbuf); 
case 1: 
#line 411 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return 0; 
case 2: 
#line 412 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return string(lexbuf); 
case 3: 
#line 413 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return string(lexbuf); 
case 4: 
#line 416 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return string(lexbuf); 
case 5: 
#line 419 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return string(lexbuf);
case 6: 
#line 421 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return string(lexbuf); 
case 7: 
#line 422 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return 0; 
case 8: 
#line 423 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return 0; 
case 9: 
#line 424 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
                      return string(lexbuf);  default:
   lexbuf->refill_buff(lexbuf);
   return string_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int string(Lexbuf<`a> lexbuf) { return string_rec(lexbuf,4); }
int slurp_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 433 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 1: 
#line 435 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputc('"',(FILE @)slurp_out);
  while (slurp_string(lexbuf)) /* skip */;
  return 1;

case 2: 
#line 442 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("*__IGNORE_FOR_CYCLONE_MALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of malloc sidestepped\n");
  return 1; 
case 3: 
#line 448 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs(" __IGNORE_FOR_CYCLONE_MALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of malloc sidestepped\n");
  return 1; 
case 4: 
#line 454 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("*__IGNORE_FOR_CYCLONE_CALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of calloc sidestepped\n");
  return 1; 
case 5: 
#line 460 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs(" __IGNORE_FOR_CYCLONE_CALLOC(",(FILE @)slurp_out);
  log("Warning: declaration of calloc sidestepped\n");
  return 1; 
case 6: 
#line 464 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("__region",(FILE @)slurp_out);
  log("Warning: use of region sidestepped\n");
  return 1; 
case 7: 
#line 468 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of __extension__ deleted\n");
  return 1; 
case 8: 
#line 472 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of nonnull attribute deleted\n");
  return 1; 
case 9: 
#line 477 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of mode HI deleted\n");
  return 1; 
case 10: 
#line 480 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of mode SI deleted\n");
  return 1; 
case 11: 
#line 483 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of mode QI deleted\n");
  return 1; 
case 12: 
#line 486 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of mode DI deleted\n");
  return 1; 
case 13: 
#line 489 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of mode DI deleted\n");
  return 1; 
case 14: 
#line 492 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of mode word deleted\n");
  return 1; 
case 15: 
#line 495 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of __attribute__((deprecated)) deleted\n");
  return 1; 
case 16: 
#line 498 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of __attribute__((__deprecated__)) deleted\n");
  return 1; 
case 17: 
#line 501 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: use of __attribute__((__transparent_union__)) deleted\n");
  return 1; 
case 18: 
#line 504 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("inline",(FILE @)slurp_out); return 1; 
case 19: 
#line 506 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("inline",(FILE @)slurp_out); return 1; 
case 20: 
#line 508 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("const",(FILE @)slurp_out); return 1; 
case 21: 
#line 510 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("const",(FILE @)slurp_out); return 1; 
case 22: 
#line 512 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("signed",(FILE @)slurp_out); return 1; 
case 23: 
#line 514 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("signed",(FILE @)slurp_out); return 1; 
case 24: 
#line 516 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("signed",(FILE @)slurp_out); return 1; 
case 25: 
#line 521 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputs("int",(FILE @)slurp_out); return 1; 
case 26: 
#line 523 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 27: 
#line 525 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputc(lexeme_char(lexbuf,0),(FILE @)slurp_out); return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return slurp_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int slurp(Lexbuf<`a> lexbuf) { return slurp_rec(lexbuf,5); }
int slurp_string_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 530 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 1: 
#line 532 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fputc('"',(FILE @)slurp_out); return 0; 
case 2: 
#line 534 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed string\n");
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; 
case 3: 
#line 537 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; 
case 4: 
#line 539 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; 
case 5: 
#line 541 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; 
case 6: 
#line 543 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; 
case 7: 
#line 545 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1; 
case 8: 
#line 547 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf((FILE @)slurp_out,"%s",lexeme(lexbuf)); return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return slurp_string_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int slurp_string(Lexbuf<`a> lexbuf) { return slurp_string_rec(lexbuf,6); }
int asmtok_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 557 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 1: 
#line 559 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  if (parens_to_match == 1) return 0;
  parens_to_match--;
  return 1; 
case 2: 
#line 563 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  parens_to_match++;
  return 1; 
case 3: 
#line 566 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  while (asm_string(lexbuf)) /* skip */;
  return 1; 
case 4: 
#line 569 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  while (asm_comment(lexbuf)) /* skip */;
  return 1; 
case 5: 
#line 572 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 6: 
#line 574 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return asmtok_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int asmtok(Lexbuf<`a> lexbuf) { return asmtok_rec(lexbuf,7); }
int asm_string_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 578 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed string\n"); return 0; 
case 1: 
#line 580 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 2: 
#line 582 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed string\n"); return 1; 
case 3: 
#line 584 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 4: 
#line 586 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 5: 
#line 588 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 6: 
#line 590 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 7: 
#line 592 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 8: 
#line 594 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return asm_string_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int asm_string(Lexbuf<`a> lexbuf) { return asm_string_rec(lexbuf,8); }
int asm_comment_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 598 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed comment\n"); return 0; 
case 1: 
#line 600 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 2: 
#line 602 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return asm_comment_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int asm_comment(Lexbuf<`a> lexbuf) { return asm_comment_rec(lexbuf,9); }
suck_line_t suck_line_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 610 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  current_line = "#define ";
  suck_macroname(lexbuf);
  return new $(current_line,(stringptr_t)current_source); 
case 1: 
#line 614 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return suck_line(lexbuf); 
case 2: 
#line 616 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return NULL;  default:
   lexbuf->refill_buff(lexbuf);
   return suck_line_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
suck_line_t suck_line(Lexbuf<`a> lexbuf) { return suck_line_rec(lexbuf,10); }
int suck_macroname_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 620 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  current_source = new (string_t)lexeme(lexbuf);
  current_line = strconcat(current_line,*current_source);
  return suck_restofline(lexbuf);
 default:
   lexbuf->refill_buff(lexbuf);
   return suck_macroname_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int suck_macroname(Lexbuf<`a> lexbuf) { return suck_macroname_rec(lexbuf,11); }
int suck_restofline_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 627 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  current_line = strconcat(current_line,lexeme(lexbuf)); return 0;  default:
   lexbuf->refill_buff(lexbuf);
   return suck_restofline_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int suck_restofline(Lexbuf<`a> lexbuf) { return suck_restofline_rec(lexbuf,12); }
spec_t spec_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 634 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return spec(lexbuf); 
case 1: 
#line 636 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  current_headerfile =
  (string_t)substring(lexeme(lexbuf), 0,
                      lexeme_end(lexbuf)-lexeme_start(lexbuf)-1);
  current_symbols = NULL;
  current_user_defs = NULL;
  current_omit_symbols = NULL;
  current_cstubs = NULL;
  current_cycstubs = NULL;
  current_hstubs = NULL;
  current_cpp = NULL;
  while (commands(lexbuf)) /* skip */;
  current_hstubs = imp_rev(current_hstubs);
  current_cstubs = imp_rev(current_cstubs);
  current_cycstubs = imp_rev(current_cycstubs);
  current_cpp = imp_rev(current_cpp);
  return new $(current_headerfile,
               current_symbols,
	       current_user_defs,
               current_omit_symbols,
               current_hstubs,
               current_cstubs,
               current_cycstubs,
               current_cpp);

case 2: 
#line 661 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return spec(lexbuf); 
case 3: 
#line 663 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return NULL; 
case 4: 
#line 665 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf(stderr,
          "Error in .cys file: expected header file name, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return NULL;  default:
   lexbuf->refill_buff(lexbuf);
   return spec_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
spec_t spec(Lexbuf<`a> lexbuf) { return spec_rec(lexbuf,13); }
int commands_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 672 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 1: 
#line 674 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 2: 
#line 676 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  snarfed_symbols = NULL;
  while (snarfsymbols(lexbuf)) /* skip */;
  current_symbols = append(snarfed_symbols,current_symbols);
  return 1; 
case 3: 
#line 681 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  snarfed_symbols = NULL;
  let tmp_user_defs = current_user_defs; 
  while (snarfsymbols(lexbuf)) /* skip */;
  if (tmp_user_defs != current_user_defs) {
    fprintf(stderr,
	    "Error in .cys file: got optional definition in omitsymbols\n");
    return 0;
  }
  current_omit_symbols = append(snarfed_symbols,current_omit_symbols);
  return 1; 
case 4: 
#line 692 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_hstubs = new List(x,current_hstubs);
  return 1; 
case 5: 
#line 700 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let s = lexeme(lexbuf);
  s += strlen("hstub");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_hstubs = new List(x,current_hstubs);
  return 1; 
case 6: 
#line 714 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cstubs = new List(x,current_cstubs);
  return 1; 
case 7: 
#line 722 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let s = lexeme(lexbuf);
  s += strlen("cstub");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cstubs = new List(x,current_cstubs);
  return 1; 
case 8: 
#line 736 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)NULL,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cycstubs = new List(x,current_cycstubs);
  return 1; 
case 9: 
#line 744 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let s = lexeme(lexbuf);
  s += strlen("cycstub");
  while (isspace(*s)) s++;
  char ?t = s;
  while (!isspace(*t)) t++;
  let symbol = substring(s,0,t-s);
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  ifdefined_t x = new $((string_t)symbol,
                        (string_t)Buffer::contents((Buffer::T)specbuf));
  current_cycstubs = new List(x,current_cycstubs);
  return 1; 
case 10: 
#line 758 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  braces_to_match = 1;
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;
  stringptr_t x = new (string_t)Buffer::contents((Buffer::T)specbuf);
  current_cpp = new List(x,current_cpp);
  return 1; 
case 11: 
#line 765 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 12: 
#line 767 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 13: 
#line 769 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf(stderr,
          "Error in .cys file: expected command, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return 0;  default:
   lexbuf->refill_buff(lexbuf);
   return commands_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int commands(Lexbuf<`a> lexbuf) { return commands_rec(lexbuf,14); }
int snarfsymbols_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 782 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  snarfed_symbols = new List(new (string_t)lexeme(lexbuf),snarfed_symbols);
  return 1; 
case 1: 
#line 785 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let s = lexeme(lexbuf);
  char ?t = s;
  while (!isspace(*t)) t++;
  current_symbol = substring(s,0,t-s);
  rename_current_symbol = true;
  braces_to_match = 1; 
  specbuf = Buffer::create(255);
  while (block(lexbuf)) /* skip */;

  rename_current_symbol = false;
  userdef_t user_def = new $(new current_symbol,
			     new (string_t)Buffer::contents((Buffer::T)specbuf));
  snarfed_symbols = new List(new (string_t)current_symbol,snarfed_symbols);
  current_user_defs = new List(user_def,current_user_defs);
  return 1; 
case 2: 
#line 801 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 1; 
case 3: 
#line 803 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  return 0; 
case 4: 
#line 805 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf(stderr,
          "Error in .cys file: unexpected end-of-file\n");
  return 0; 
case 5: 
#line 809 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  fprintf(stderr,
          "Error in .cys file: expected symbol, found '%c' instead\n",
          lexeme_char(lexbuf,0));
  return 0;  default:
   lexbuf->refill_buff(lexbuf);
   return snarfsymbols_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int snarfsymbols(Lexbuf<`a> lexbuf) { return snarfsymbols_rec(lexbuf,15); }
int block_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 822 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed brace\n"); return 0; 
case 1: 
#line 824 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  if (braces_to_match == 1) return 0;
  braces_to_match--;
  Buffer::add_char((Buffer::T)specbuf,'}');
  return 1; 
case 2: 
#line 829 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  braces_to_match++;
  Buffer::add_char((Buffer::T)specbuf,'{');
  return 1; 
case 3: 
#line 833 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_char((Buffer::T)specbuf,'"');
  while (block_string(lexbuf)) /* skip */;
  return 1; 
case 4: 
#line 837 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,"/*");
  while (block_comment(lexbuf)) /* skip */;
  return 1; 
case 5: 
#line 841 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; 
case 6: 
#line 844 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  let symbol = (string_t)lexeme(lexbuf);
  if (rename_current_symbol && !strcmp(symbol,current_symbol))
    Buffer::add_string((Buffer::T)specbuf, *add_user_prefix(new symbol));
  else
    Buffer::add_string((Buffer::T)specbuf,symbol);
  return 1; 
case 7: 
#line 851 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_char((Buffer::T)specbuf,lexeme_char(lexbuf,0));
  return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return block_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int block(Lexbuf<`a> lexbuf) { return block_rec(lexbuf,16); }
int block_string_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 856 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed string\n"); return 0; 
case 1: 
#line 858 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_char((Buffer::T)specbuf,'"'); return 0; 
case 2: 
#line 860 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed string\n");
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; 
case 3: 
#line 864 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; 
case 4: 
#line 867 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; 
case 5: 
#line 870 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; 
case 6: 
#line 873 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; 
case 7: 
#line 876 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1; 
case 8: 
#line 879 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return block_string_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int block_string(Lexbuf<`a> lexbuf) { return block_string_rec(lexbuf,17); }
int block_comment_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 884 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  log("Warning: unclosed comment\n"); return 0; 
case 1: 
#line 886 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,"*/"); return 0; 
case 2: 
#line 888 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
  Buffer::add_string((Buffer::T)specbuf,lexeme(lexbuf));
  return 1;  default:
   lexbuf->refill_buff(lexbuf);
   return block_comment_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
int block_comment(Lexbuf<`a> lexbuf) { return block_comment_rec(lexbuf,18); }

}
#line 891 "/home/pgerakios/reglock/branches/cyclone/0.8.3/src/buildlib.cyl"
 

//  static void pr(stringptr_t sptr) {
//    log(" %s\n",*sptr);
//  }

  /* Type for representing dependencies */
  typedef Hashtable::table_t<stringptr_t<`H,`H>,
                             Set::set_t<stringptr_t<`H,`H>,`H>> dep_t;

  extern void scan_type(type_t t, dep_t dep);
  void scan_exp(exp_opt_t e, dep_t dep) {
    switch (e->r) {
    case &Var_e(b):
      let v = (*binding2qvar(b))[1];
      add_target(v);
      return;
    case &Primop_e(_,x):
      for (; x != NULL; x = x->tl) {
        scan_exp(x->hd,dep);
      }
      return;
    case &Subscript_e(e1,e2):
      fallthru(e1,e2);
    case &SeqExp_e(e1,e2):
      fallthru(e1,e2);
    case &AssignOp_e(e1,_,e2):
      scan_exp(e1,dep);
      scan_exp(e2,dep);
      return;
    case &Extension_e(e1): fallthru(e1);
    case &Deref_e(e1):
      fallthru(e1);
    case &Sizeofexp_e(e1):
      fallthru(e1);
    case &Address_e(e1):
      fallthru(e1);
    case &Increment_e(e1,_):
      scan_exp(e1,dep);
      return;
    case &Conditional_e(e1,e2,e3):
      scan_exp(e1,dep);
      scan_exp(e2,dep);
      scan_exp(e3,dep);
      return;
    case &And_e(e1,e2): fallthru(e1,e2);
    case &Or_e(e1,e2):
      scan_exp(e1,dep);
      scan_exp(e2,dep);
      return;
    case &FnCall_e(e1,x,_,_):
      scan_exp(e1,dep);
      for (; x != NULL; x = x->tl) {
        scan_exp(x->hd,dep);
      }
      return;
    case &Cast_e(t1,e1,_,_):
      scan_type(t1,dep);
      scan_exp(e1,dep);
      return;
    case &Malloc_e(MallocInfo{iscalloc,ropt,topt,e,_,_}):
      if (ropt != NULL) scan_exp((exp_t)ropt,dep);
      if (topt != NULL) scan_type(*topt,dep);
      scan_exp(e,dep);
      return;
    case &Tagcheck_e(e,_):
      scan_exp(e,dep); return;
    case &Valueof_e(t1): fallthru(t1);
    case &Sizeoftype_e(t1):
      scan_type(t1,dep);
      return;
    case &AggrMember_e(e1,fn,...):
      fallthru(e1,fn);
    case &AggrArrow_e(e1,fn,...):
      scan_exp(e1,dep);
      add_target(fn);
      return;
    case &Offsetof_e(t1,f):
      scan_type(t1,dep);
      // FIX: add targets for nested fields too?
      switch (f->hd) {
      case &StructField(fn): add_target(fn); break;
      case &TupleIndex(_): break;
      }
      return;
    case &Const_e(_):
      return;
    case &UnresolvedMem_e(_,x):
      for (; x != NULL; x = x->tl) {
        let &$(_,e1) = x->hd;
        scan_exp(e1,dep);
      }
      return;
    case &Asm_e(...): return;
    case &Pragma_e(_):
      fprintf(stderr,"Error: unexpected Pragma_e\n");
      exit(1); return;
    case &Swap_e(_,_):
      fprintf(stderr,"Error: unexpected Swap_e\n");
      exit(1); return;
    case &StmtExp_e(_):
      fprintf(stderr,"Error: unexpected Stmt_e\n");
      exit(1); return;
    case &Throw_e(...):
      fprintf(stderr,"Error: unexpected Throw_e\n");
      exit(1); return;
    case &NoInstantiate_e(_):
      fprintf(stderr,"Error: unexpected NoInstantiate_e\n");
      exit(1); return;
    case &Instantiate_e(_,_):
      fprintf(stderr,"Error: unexpected Instantiate_e\n");
      exit(1); return;
    case &New_e(_,_):
      fprintf(stderr,"Error: unexpected New_e\n");
      exit(1); return;
    case &Tuple_e(_):
      fprintf(stderr,"Error: unexpected Tuple_e\n");
      exit(1); return;
     case &Spawn_e(...):
      fprintf(stderr,"Error: unexpected Spawn_e\n");
      exit(1); return;
    case &CompoundLit_e(_,_):
      fprintf(stderr,"Error: unexpected CompoundLit_e\n");
      exit(1); return;
    case &Array_e(_):
      fprintf(stderr,"Error: unexpected Array_e\n");
      exit(1); return;
    case &Comprehension_e(_,_,_,_):
      fprintf(stderr,"Error: unexpected Comprehension_e\n");
      exit(1); return;
    case &ComprehensionNoinit_e(...):
      fprintf(stderr,"Error: unexpected ComprehensionNoinit_e\n");
      exit(1); return;
    case &Aggregate_e(_,_,_,_):
      fprintf(stderr,"Error: unexpected Aggregate_e\n");
      exit(1); return;
    case &AnonStruct_e(_,_):
      fprintf(stderr,"Error: unexpected AnonStruct_e\n");
      exit(1); return;
    case &Datatype_e(_,_,_):
      fprintf(stderr,"Error: unexpected Datatype_e\n");
      exit(1); return;
    case &Enum_e(...):
      fprintf(stderr,"Error: unexpected Enum_e\n");
      exit(1); return;
    case &AnonEnum_e(...):
      fprintf(stderr,"Error: unexpected AnonEnum_e\n");
      exit(1); return;
    }
  }

  void scan_exp_opt(exp_opt_t eo, dep_t dep) {
    if (eo) scan_exp(eo,dep);
    return;
  }

  extern void scan_decl(decl_t d, dep_t dep);
  void scan_type(type_t t, dep_t dep) {
    switch (t) {
    case &AppType(c,ts):
      switch (c) {
      case &VoidCon:
      case &IntCon(_,_):
      case &BuiltinCon(...):
      case &FloatCon(_):
      case &AnonEnumCon(_):
        return;
      case &AggrCon(info):
        let $(_,&$(_,v)) = aggr_kinded_name(info);
        fallthru(v);
      case &EnumCon(&$(_,v),_): add_target(v); return;
      case &DatatypeCon(_):        case &DatatypeFieldCon(_):
      case &RgnHandleCon:          case &HeapCon:
      case &UniqueCon:             case &RefCntCon:
      case &AccessCon:             case &JoinCon:
      case &RgnsCon:               case &TagCon:
      case &TrueCon:               case &FalseCon:
      case &ThinCon:               case &FatCon:
        fprintf(stderr,"Error: unexpected type %s\n",Absynpp::typ2string(t));
        exit(1); return;
      }

    case &PointerType(x):
      scan_type(x.elt_type,dep);
      return;
    case &ArrayType(ArrayInfo{t,_,sz,zt,_}):
      scan_type(t,dep);
      scan_exp_opt(sz,dep);
      return;
    case &TypeofType(e):
      scan_exp(e, dep);
      return;
    case &FnType(x):
      scan_type(x.ret_type,dep);
      for (let a = x.args; a != NULL; a = a->tl) {
        let &$(_,_,argt) = a->hd;
        scan_type(argt,dep);
      }
      if (x.cyc_varargs != NULL)
        scan_type(x.cyc_varargs->type,dep);
      return;
    case &AnonAggrType(_,sfs):
      for (; sfs != NULL; sfs = sfs->tl) {
        scan_type(sfs->hd->type,dep);
        scan_exp_opt(sfs->hd->width,dep);
      }
      return;
    case &TypedefType(&$(_,v),_,_,_):
      add_target(v);
      return;

    case &TypeDeclType(&{.r = &Aggr_td(x),...},_):
      scan_decl(new_decl(new Aggr_d(x),0),dep);
      let &$(_,n) = x->name;
      add_target(n);
      return;

    case &TypeDeclType(&{.r = &Enum_td(x),...},_):
      scan_decl(new_decl(new Enum_d(x),0),dep);
      let &$(_,n) = x->name;
      add_target(n);
      return;

    case &TypeDeclType(&{.r = &Datatype_td(dd),...},_):
      fprintf(stderr,"Error: unexpected Datatype declaration\n");
      exit(1); return;
    case &Evar(_,_,_,_):
      fprintf(stderr,"Error: unexpected Evar\n");
      exit(1); return;
    case &VarType(_):
      fprintf(stderr,"Error: unexpected VarType\n");
      exit(1); return;
    case &TupleType(_):
      fprintf(stderr,"Error: unexpected TupleType\n");
      exit(1); return;
    case &ValueofType(_):
      fprintf(stderr,"Error: unexpected valueof_t\n");
      exit(1); return;
    }
  }

  void scan_decl(decl_t d, dep_t dep) {
    let saved_targets = current_targets;
    let saved_source = current_source;
    current_targets = new Set::empty(strptrcmp);
    switch (d->r) {
    case &Var_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      scan_type(x->type,dep);
      scan_exp_opt(x->initializer,dep);
      break;
    case &Fn_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      scan_type(x->i.ret_type,dep);
      for (let a = x->i.args; a != NULL; a = a->tl) {
        let &$(_,_,t1) = a->hd;
        scan_type(t1,dep);
      }
      if (x->i.cyc_varargs != NULL)
        scan_type(x->i.cyc_varargs->type,dep);
      if (x->is_inline)
        fprintf(stderr,"Warning: ignoring inline function\n");
      break;
    case &Aggr_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      if (x->impl) {
        for (let fs = x->impl->fields; fs != NULL; fs = fs->tl) {
          let f = fs->hd;
          scan_type(f->type,dep);
          scan_exp_opt(f->width,dep);
        }
        // That takes care of what the decl depends on.  Now must add
        // that each field depends on the decl.
        for (let fs = x->impl->fields; fs != NULL; fs = fs->tl) {
          // FIX!!
        }
      }
      break;
    case &Enum_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      if (x->fields) {
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          let f = fs->hd;
          scan_exp_opt(f->tag,dep);
        }
        // That takes care of what the decl depends on.  Now must add
        // that each field depends on the decl.
        for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
          // FIX!!
        }
      }
      break;
    case &Typedef_d(x):
      let &$(_,v) = x->name;
      current_source = v;
      if (x->defn)
        scan_type((type_t)x->defn,dep);
      break;
    case &Region_d(...):
      fprintf(stderr,"Error: unexpected region declaration");
      exit(1); 
    case &Porton_d:
      fprintf(stderr,"Error: unexpected __cyclone_port_on__");
      exit(1);
    case &Portoff_d:
      fprintf(stderr,"Error: unexpected __cyclone_port_off__");
      exit(1);
    case &Tempeston_d:
      fprintf(stderr,"Error: unexpected __tempest_on__");
      exit(1);
    case &Tempestoff_d:
      fprintf(stderr,"Error: unexpected __tempest_off__");
      exit(1);
    case &Let_d(...):
      fprintf(stderr,"Error: unexpected let declaration\n");
      exit(1);
    case &Datatype_d(_):
      fprintf(stderr,"Error: unexpected datatype declaration\n");
      exit(1);
    case &Letv_d(_):
      fprintf(stderr,"Error: unexpected let declaration\n");
      exit(1);
    case &Namespace_d(_,_):
      fprintf(stderr,"Error: unexpected namespace declaration\n");
      exit(1);
    case &Using_d(_,_):
      fprintf(stderr,"Error: unexpected using declaration\n");
      exit(1);
    case &ExternC_d(...):
      fprintf(stderr,"Error: unexpected extern \"C\" declaration\n");
      exit(1);
    case &ExternCinclude_d(...):
      fprintf(stderr,"Error: unexpected extern \"C include\" declaration\n");
      exit(1);
    }

    /* Add the dependencies to the table.  Note that name might
       already have an entry in the table -- there can be more than
       one declaration for a name, e.g., struct stat and function
       stat in sys/stat.h. */
    let old;
    let name = (_@)current_source;
    try
      old = Hashtable::lookup(dep,name);
    catch {
    case &Not_found: old = Set::empty(strptrcmp); break;
    }
    let targets = Set::union_two(*current_targets,old);
    Hashtable::insert(dep,name,targets);

    current_targets = saved_targets;
    current_source = saved_source;
  }

  dep_t new_deps() {
    return Hashtable::create(107,strptrcmp,Hashtable::hash_stringptr);
  }

  Set::set_t<stringptr_t<`H,`H>,`H> find(dep_t t, stringptr_t<`H,`H> x) {
    try return Hashtable::lookup(t,x);
    catch {
    case &Not_found: return Set::empty(strptrcmp);
    }
  }

  Set::set_t<stringptr_t> reachable(list_t<stringptr_t<`H,`H>> init, dep_t t) {
    /* Maintain two sets, curr and delta: curr is the "current set"
       and delta is the subset of curr that was added in the previous
       step.  Initially curr = delta = the initial nodes.

       While delta is not empty,
         find a set, next, that consists of the nodes reachable
           from delta in a single step;
         set delta = next - curr, and curr = curr U delta.
    */
    Set::set_t<stringptr_t<`H,`H>,`H> emptyset = Set::empty(strptrcmp);
    Set::set_t<stringptr_t<`H,`H>,`H> curr;
    for (curr = emptyset; init != NULL; init = init->tl) {
      curr = Set::insert(curr,init->hd);
    }
    let delta = curr;

    let sptr = new "";
    while (Set::cardinality(delta) > 0) {
      let next = emptyset;
      let iter = Set::make_iter(Core::heap_region,delta);
      while(Iter::next(iter,&sptr))
        next = Set::union_two(next,find(t,sptr));
      delta = Set::diff(next,curr);
      curr = Set::union_two(curr,delta);
    }
    return curr;
  }

  enum buildlib_mode { NORMAL, GATHER, GATHERSCRIPT, FINISH };
  static enum buildlib_mode mode = NORMAL;
  static int gathering() {
    return (mode == GATHER) || (mode == GATHERSCRIPT) ;
  }

  static FILE *script_file = NULL;
  int prscript(const char ?fmt, ... inject parg_t<`r2> ap)
    __attribute__((format(printf,1,2)))
  {
    if (script_file == NULL) {
      fprintf(stderr,"Internal error: script file is NULL\n");
      exit(1);
    }
    return vfprintf((FILE@)script_file,fmt,ap);
  }

  int force_directory(string_t d) {
    if (mode == GATHERSCRIPT) {
      prscript("if ! test -e %s; then mkdir %s; fi\n",d,d);
    }
    else {
      /* We could do this with stat, but stat is more
         platform dependent; this is more portable. */
      let fd = open(d,O_RDONLY);
      if (fd == -1) {
        if (mkdir((const char @)d,0700) == -1) {
          fprintf(stderr,"Error: could not create directory %s\n",d);
          return 1;
        }
      }
      else close(fd);
    }
    return 0;
  }

  int force_directory_prefixes(string_t file) {
    /* File is a string like "foo/bar/baz/xx.h", we want to make sure
       that the directories "foo", "foo/bar", "foo/bar/baz" all exist
       so we can create file. */
    let curr = strdup(file); // Make sure curr is on heap
    /* Compute all prefixes of file */
    let x = NULL;
    while (true) {
      curr = Filename::dirname(curr);
      if (strlen(curr) == 0) break;
      x = new List(new (string_t)curr,x);
    }
    /* Make sure all prefixes exist */
    for (; x != NULL; x = x->tl) {
      if (force_directory(*x->hd)) return 1;
    }
    return 0;
  }

  /* Exception for handling error cases of process_file */
  datatype exn { NO_SUPPORT(string_t) };

  /* Is a character special to /bin/sh (except for single quote)? */
  static bool is_other_special(char c) {
    switch (c) {
    case '\\':
    case '"':
    case ';':
    case '&':
    case '(':
    case ')':
    case '|':
    case '^':
    case '<':
    case '>':
    // JGM: I'm commenting this out because we shouldn't be quoting
    // arguments like -idirafter.
    // case ' ':
    case '\n':
    case '\t': return true;
    default: return false;
    }
  }
  /* Escape any characters special to /bin/sh */
  static string_t sh_escape_string(string_t<`H> s) {
    let len = strlen(s);

    /* Count the number of single quotes and other special chars in s */
    let single_quotes = 0;
    let other_special = 0;
    for (int i = 0; i < len; i++) {
      let c = s[i];
      if (c == '\'') single_quotes++;
      else if (is_other_special(c)) other_special++;
    }

    /* No special chars to escape */
    if (single_quotes == 0 && other_special == 0)
      return s;

    /* No single quotes, we can just single quote s */
    if (single_quotes == 0)
      return strconcat_l(list(new "'",new (string_t)s, new "'"));

    /* We'll quote all special chars by prefixing with a backslash */
    let len2 = len + single_quotes + other_special;
    mstring_t s2 = new {for i < len2+1 : '\0'}; // add trailing NUL
    let i = 0;
    let j = 0;
    for (; i < len; i++) {
      let c = s[i];
      if (c == '\'' || is_other_special(c))
        s2[j++] = '\\';
      s2[j++] = c;
    }
    return s2;
  }
  static stringptr_t sh_escape_stringptr(stringptr_t<`H,`H> sp) {
    return new sh_escape_string(*sp);
  }

  /* Returns 1 on a fatal error (can't create files, etc.) or 0 otherwise. */
  int process_file(const char @ filename,
                   list_t<stringptr_t<`H,`H>,`H> start_symbols,
                   list_t<userdef_t,`H> user_defs,
                   list_t<stringptr_t<`H,`H>,`H> omit_symbols,
                   list_t<ifdefined_t,`H> hstubs,
                   list_t<ifdefined_t,`H> cstubs,
                   list_t<ifdefined_t,`H> cycstubs,
                   list_t<stringptr_t<`H,`H>,`H> cpp_insert) {
    FILE *maybe;
    FILE @in_file;
    FILE @out_file;
    int errorcode = 0;

    fprintf(stderr,
            "********************************* %s...\n",filename);

    if (!gathering()) log("\n%s:\n",filename);

    /* Calculate necessary file names.  For example:
       filename = sys/types.h
       basename = types.h
       dirname = sys
       choppedname = types
       cppinfile = types.iA
       macrosfile = sys/types.iB
       declsfile = sys/types.iC
       filtereddeclsfile = sys/types.iD
    */
    let basename = Filename::basename(filename);
    let dirname = Filename::dirname(filename);
    let choppedname = Filename::chop_extension(basename);
    let cppinfile = (const char @)(strconcat(choppedname, ".iA"));
    /* The macrosfile just contains the #define's in the header (filename) */
    let macrosfile = (const char @)
      ((numelts(dirname) == 0)?
      (aprintf("%s.iB", choppedname)):
      (Filename::concat(dirname, aprintf("%s.iB", choppedname))));
    /* The declsfile contains all of the (preprocessed) declarations in the header */
    let declsfile = (const char @)
      ((numelts(dirname) == 0)?
      (aprintf("%s.iC", choppedname)):
      (Filename::concat(dirname, aprintf("%s.iC", choppedname))));
    /* The filtereddeclsfile is the declsfile minus Cyclone-unfriendly constructs */
    let filtereddeclsfile = (const char @)
      ((numelts(dirname) == 0)?
      (aprintf("%s.iD", choppedname)):
      (Filename::concat(dirname, aprintf("%s.iD", choppedname))));

    try {

    /* Make sure we'll be able to create files in the right directories */
    if (force_directory_prefixes(filename)) {
      return 1;
    }

    /* Create the file of macros and the file of declarations */
    if (mode != FINISH) {
      if (mode == GATHERSCRIPT) {
        prscript("cat >%s <<XXX\n",cppinfile);
        for (let l = cpp_insert; l != NULL; l = l->tl)
          prscript("%s",*(l->hd));
        prscript("#include <%s>\n",filename);
        prscript("XXX\n");
        prscript("$GCC %s -E -dM -o %s -x c %s && \\\n",target_cflags,macrosfile,cppinfile);
        prscript("$GCC %s -E     -o %s -x c %s;\n",target_cflags,declsfile,cppinfile);
        prscript("rm %s\n",cppinfile);
      }
      else {
        maybe = fopen(cppinfile,"w");
        if (!maybe) {
          fprintf(stderr,"Error: could not create file %s\n",cppinfile);
          return 1;
        }
	if (verbose)
          fprintf(stderr,"Creating %s\n",cppinfile);
        out_file = (FILE@)maybe;
        for (let l = cpp_insert; l != NULL; l = l->tl) {
          fputs((const char @)(*(l->hd)),out_file);
        }
        fprintf(out_file,"#include <%s>\n",filename);
        fclose(out_file);
        let cppargs_string =
          str_sepstr(new List(new (string_t)"",
                              List::map(sh_escape_stringptr,rev(cppargs))),
                     " ");
        char @cmd = (char @)aprintf("%s %s %s -E -dM -o %s -x c %s",
				    cyclone_cc,target_cflags,
                                    cppargs_string,macrosfile,cppinfile);
        if (verbose)
          fprintf(stderr,"%s\n",cmd);
        if (!system(cmd)) {
          /* No error in creating the file of macros, so go ahead and create
             the file of declarations */
          cmd = (char @)aprintf("%s %s %s -E -o %s -x c %s",
				cyclone_cc,target_cflags,
                                cppargs_string,declsfile,cppinfile);
          if (verbose)
            fprintf(stderr,"%s\n",cmd);
          system(cmd); // if err, no declsfile created, and we'll handle later
        }
        //JGM:remove(cppinfile);
      }
    }
    if (gathering()) return 0;

    /* Put the macros in the table of dependencies */
    dep_t t = new_deps();
    maybe = fopen(macrosfile,"r");
    if (!maybe) throw new NO_SUPPORT(aprintf("can't open macrosfile %s",
                                             macrosfile));

    in_file = (FILE@)maybe;
    let l = Lexing::from_file(in_file);
    let entry;
    while ( (entry = line(l)) != NULL) {
      let &$(name,uses) = (_ @)entry; // force NULL check to get rid of warning
      Hashtable::insert(t,name,uses);
      //      log("Macro %s uses:\n",*name);
      //      Set::iter(pr,uses);
    }
    fclose(in_file);

    /* Get the type declarations out of the file */
    maybe = fopen(declsfile,"r");
    if (!maybe) throw new NO_SUPPORT(aprintf("can't open declsfile %s",
                                             declsfile));

    in_file = (FILE@)maybe;
    l = Lexing::from_file(in_file);
    slurp_out = fopen(filtereddeclsfile,"w");
    if (!slurp_out) return 1;
    while (slurp(l)) /* skip */;
    // Now include (renamed) user-defined declarations
    let x = user_defs;
    while (x != NULL) {
      let &$(_,s) = x->hd;
      fprintf((FILE@)slurp_out,"%s",*s);
      x = x->tl;
    }
    fclose(in_file);
    fclose((FILE @)slurp_out);
    if (mode != FINISH) //JGM:remove(declsfile);
      ;


    maybe = fopen(filtereddeclsfile,"r");
    if (!maybe) return 1;
    in_file = (FILE@)maybe;
    Position::reset_position(filtereddeclsfile);
    Lex::lex_init(false);// must forget typedefs, may as well flush symbols too
    let decls = Parse::parse_file(in_file,filtereddeclsfile);
    Lex::lex_init(false); // garbage collect those big tries
    fclose(in_file);
    //JGM:remove(filtereddeclsfile);

    for (let d = decls; d != NULL; d = d->tl)
      scan_decl(d->hd,t);

    /* Compute reachable symbols (including user decls) */
    let user_symbols = map(add_user_prefix,(split(user_defs))[0]);
    let reachable_set = reachable(append(start_symbols,user_symbols),t);

    /* Print reachable declarations */
    let reachable_decls = NULL;
    let user_decls = NULL;
    Set::set_t<stringptr_t<`H,`H>> defined_symbols = Set::empty(strptrcmp);
    for (let d = decls; d != NULL; d = d->tl) {
      let decl = d->hd;
      let name;
      switch (decl->r) {
      case &Var_d(x):
        let &$(_,v) = x->name;
        defined_symbols = Set::insert(defined_symbols,v);
        if (mem(strptrcmp,omit_symbols,v)) name = NULL;
        else name = v;
        break;
      case &Fn_d(x):
        let &$(_,v) = x->name;
        defined_symbols = Set::insert(defined_symbols,v);
        if (mem(strptrcmp,omit_symbols,v)) name = NULL;
        else name = v;
        break;
      case &Aggr_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Enum_d(x):
        let &$(_,v) = x->name;
        name = v;

        // see if fields are reachable or name is reachable
        if (name != NULL && Set::member(reachable_set,(stringptr_t)name)) {
	  reachable_decls = new List(decl,reachable_decls);
	}
        else if (x->fields) {
          for (let fs = x->fields->v; fs != NULL; fs = fs->tl) {
            let f = fs->hd;
            let &$(_,v) = f->name;
            if (Set::member(reachable_set,v)) {
              reachable_decls = new List(decl,reachable_decls);
              break; // exit for-loop
            }
          }
        }
        name = NULL;
        break;
      case &Typedef_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Porton_d:
      case &Portoff_d:
      case &Tempeston_d:
      case &Tempestoff_d:
      case &Let_d(...):
      case &Datatype_d(_):
      case &Letv_d(_):
      case &Namespace_d(_,_):
      case &Using_d(_,_):
      case &ExternC_d(...):
      case &ExternCinclude_d(...):
      case &Region_d(...):
        name = NULL;
        break;
      }
      // two lists: one for reachable decls, one for user decls
      if (name != NULL && Set::member(reachable_set,(stringptr_t)name)) {
	if (strncmp(*name,user_prefix,strlen(user_prefix)) != 0) {
	  reachable_decls = new List(decl,reachable_decls);
	}
	else {
	  rename_decl(decl);
	  user_decls = new List(decl,user_decls);
	}
      }
    }

    // reachable_decls = imp_rev(reachable_decls);
    if (!do_setjmp) {
      maybe = fopen(filename,"w");
      if (!maybe) return 1;
      out_file = (FILE @)maybe;
    } else out_file = stdout;
    mstring_t ifdefmacro = aprintf("_%s_",filename);
    for (let j = 0; j < numelts(ifdefmacro); j++) {
      if (ifdefmacro[j] == '.' || ifdefmacro[j] == '/')
        ifdefmacro[j] = '_';
      else if (ifdefmacro[j] != '_' && ifdefmacro[j] != '/')
        ifdefmacro[j] = (char)toupper(ifdefmacro[j]);
    }
    fprintf(out_file,
            "#ifndef %s\n"
            "#define %s\n",
            ifdefmacro,
            ifdefmacro);

    /* gather all of the declarations to print */
    let print_decls = NULL;
    let names = NULL;
    for (let d = reachable_decls; d != NULL; d = d->tl) {
      let decl = d->hd;
      let anon_enum = false;
      _* name;
      switch (decl->r) {
      case &Var_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Fn_d(x):
	if(x->is_inline) { name = NULL; break; } // DJG: ??
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Aggr_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Enum_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Typedef_d(x):
        let &$(_,v) = x->name;
        name = v;
        break;
      case &Region_d(...): 
      case &Porton_d:
      case &Portoff_d:
      case &Tempeston_d:
      case &Tempestoff_d:
      case &Let_d(...):
      case &Datatype_d(_):
      case &Letv_d(_):
      case &Namespace_d(_,_):
      case &Using_d(_,_):
      case &ExternC_d(...): 
      case &ExternCinclude_d(...):
	name = NULL;
        break;
      }
      if (!name && !anon_enum) continue;

      // If this has a user declaration, merge it with the system declaration.
      // If the two are not representation-compatible, will signal a warning and
      // stick with the system definition.
      if (Set::member(reachable_set,add_user_prefix(name))) {
	let user_decl = lookup_decl(user_decls,name);
	if (user_decl == NULL) {
	  throw new Core::Impossible("Internal Error: bad user-def name");
	}
	else {
	  switch (user_decl->r) {
	  case &Var_d(_):
	  case &Fn_d(_):
	    throw new NO_SUPPORT("user defintions for function or variable decls");
	  default: break;
	  }
	}
	Cifc::merge_sys_user_decl(0, true, user_decl, decl);
	print_decls = new List(decl,print_decls);
      }
      else
	print_decls = new List(decl,print_decls);
      names = new List(name,names);
    }

    /* make sure the declarations are well-formed */
    try {
      Binding::resolve_all(print_decls);
      Tc::tc(Tcenv::tc_init(), true, print_decls);
    } catch { default:
      throw new NO_SUPPORT("can't typecheck acquired declarations");
    }    

    /* print them */
    for (let $(d,n) = $(print_decls, names);
	 d != NULL && n != NULL; d = d->tl, n = n->tl) {
      let decl = d->hd;
      let name = n->hd;
      let anon_enum = false;
      if (!name)
	anon_enum = true;

      // set up the pretty printer to emit interfaces
      Absynpp::set_params(&Absynpp::cyc_params_r);
      if (name) {
        ifdefmacro = aprintf("_%s_def_",*name);
        fprintf(out_file,"#ifndef %s\n",ifdefmacro);
        fprintf(out_file,"#define %s\n",ifdefmacro);
        // Because there's no decl2file and I'm lazy
        Absynpp::decllist2file(list(decl),out_file);
        fprintf(out_file,"#endif\n");
      }
      else {
        // Anonymous enum
        Absynpp::decllist2file(list(decl),out_file);
      }
    }

    /* Print reachable macros */
    maybe = fopen(macrosfile,"r");
    if (!maybe) throw new NO_SUPPORT(aprintf("can't open macrosfile %s",
                                             macrosfile));
    in_file = (FILE@)maybe;
    l = Lexing::from_file(in_file);
    let entry2;
    while ( (entry2 = suck_line(l)) != NULL) {
      let &$(line,name) = (_ @)entry2; // force NULL check to get rid of warning
      if (Set::member(reachable_set,name)) {
        fprintf(out_file,"#ifndef %s\n",*name);
        fprintf(out_file,"%s\n",line);
        fprintf(out_file,"#endif\n");
      }
    }
    fclose(in_file);
    if (mode != FINISH) ; //JGM:remove(macrosfile);

    if (hstubs != NULL) {
      for (let x = hstubs; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          // FIX: FPUTS DUMPS CORE ON LINUX IF FIRST ARG IS NULL!!
          fputs((const char @)text,out_file);
        else
          log("%s is not supported on this platform\n",symbol);
      }
    }
    fprintf(out_file,"#endif\n");
    if (do_setjmp) return 0; // Don't print C and Cyclone stubs files
    else fclose(out_file);

    /* Dump out the C stubs */
    if (cstubs != NULL) {
      out_file = (FILE @)cstubs_file;
      for (let x = cstubs; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          fputs((const char @)text,out_file);
      }
    }

    /* Dump out the Cyclone stubs */
    out_file = (FILE @)cycstubs_file;
    /* Always include the header, to make sure it has no errors */
    fprintf(out_file, "#include <%s>\n\n", filename);
    if (cycstubs != NULL) {
      out_file = (FILE @)cycstubs_file;
      for (let x = cycstubs; x != NULL; x = x->tl) {
        let &$(symbol,text) = x->hd;
        if (text != NULL &&
            (symbol == NULL || Set::member(defined_symbols, new symbol)))
          fputs((const char @)text,out_file);
      }
      fprintf(out_file, "\n");
    }

    return 0;

    } catch {
    case &Core::Impossible(s):
      fprintf(stderr,"Got Core::Impossible(%s)\n",s); break;
    case &Dict::Absent:
      fprintf(stderr,"Got Dict::Absent\n"); break;
    case &Core::Failure(s):
  	   fprintf(stderr,"exception from file %s, line %d was thrown\n",
                get_exn_filename(), get_exn_lineno());
      fprintf(stderr,"Got Core::Failure(%s)\n",s); break;
    case &Invalid_argument(s):
      fprintf(stderr,"Got Invalid_argument(%s)\n",s); break;
    case &Not_found:
      fprintf(stderr,"Got Not_found\n"); break;
    case &NO_SUPPORT(s):
      fprintf(stderr,"No support because %s\n",s); break;
    case x:
      fprintf(stderr,"Got unknown exception\n");
      rethrow(x);
    }
      /* We could get here because of a throw NO_SUPPORT or because of
         a parse error or other error.  In either case, we create a
         default header and don't otherwise signal an error. */
      maybe = fopen(filename,"w");
      if (!maybe) {
        fprintf(stderr,"Error: could not create file %s\n",filename);
        return 1;
      }
      out_file = (FILE@)maybe;
      fprintf(out_file,
              "#error -- %s is not supported on this platform\n",
              filename);
      fclose(out_file);
      fprintf(stderr,"Warning: %s will not be supported on this platform\n",
              filename);
      log("Not supported on this platform\n");


      /* Delete intermediate files; some may not exist but we ignore that */
      //JGM:remove(macrosfile);
      //JGM:remove(declsfile);
      //JGM:remove(filtereddeclsfile);

      return 0;
  }

  /* Return 1 on fatal error, else 0 */
  int process_specfile(const char @ file,const char @ dir) {
    if (verbose)
      fprintf(stderr,"Processing %s\n",file);
    let maybe = fopen(file,"r");
    if (!maybe) {
      fprintf(stderr,"Error: could not open %s\n", file);
      return 1;
    }
    let in_file = (FILE@)maybe;

    /* Cd into dir, where the header files will be built.  Remember
       the current dir so we can cd back after we're done. */
    char ? buf = new {for i<1024: '\0'};
    let cwd = getcwd(buf,numelts(buf));
    if (mode != GATHERSCRIPT) {
      if (chdir(dir)) {
        fprintf(stderr,"Error: can't change directory to %s\n",dir);
        return 1;
      }
    }
    if (mode == GATHER) {
      /* This will be executed once for each specfile, but who cares */
      let cmd = aprintf("echo | %s %s -E -dM - -o INITMACROS.h\n",
                        cyclone_cc,target_cflags);
      if (verbose)
        fprintf(stderr,"%s\n",cmd);
      system((const char @)cmd);
    }

    let l = Lexing::from_file(in_file);
    let entry;
    while ( (entry = spec(l)) != NULL) {
      let &$(headerfile,start_symbols,user_defs,omit_symbols,
             hstubs,cstubs,cycstubs,cpp_insert) = (_ @)entry;
      if (process_file((const char @)headerfile,start_symbols,user_defs,omit_symbols, 
                       hstubs,cstubs,cycstubs,cpp_insert))
        return 1; /* fatal error in process_file */
    }
    fclose(in_file);

    if (mode != GATHERSCRIPT) {
      if (chdir((char @)cwd)) {
        fprintf(stderr,"Error: could not change directory to %s\n", cwd);
        return 1;
      }
    }
    return 0;
  }

  /* Return 1 on fatal error, else 0 */
  int process_setjmp(const char @ dir) {
    /* Cd into dir, where the header files will be built.  Remember
       the current dir so we can cd back after we're done. */
    char ? buf = new {for i<1024: '\0'};
    let cwd = getcwd(buf,numelts(buf));
    if (chdir(dir)) {
      fprintf(stderr,"Error: can't change directory to %s\n",dir);
      return 1;
    }
    if (process_file("setjmp.h", list(new "jmp_buf"), NULL, NULL,
                     list(new $("setjmp", "extern int setjmp(jmp_buf);\n")),
                     NULL, NULL, NULL))
      return 1; /* fatal error */
    if (chdir((char @)cwd)) {
      fprintf(stderr,"Error: could not change directory to %s\n", cwd);
      return 1;
    }
    return 0;
  }

  /* Helper functions for command line argument processing */
  static string_t output_dir = "BUILDLIB.OUT";
  static void set_output_dir(string_t<`H> s) {
    output_dir = s;
  }
  static list_t<const char @`H> spec_files = NULL;
  static void add_spec_file(string_t<`H> s) {
    spec_files = new List((const char @)s,spec_files);
  }
  static bool no_other(string_t<`H> s) { return false; }
  static void set_GATHER() {
    mode = GATHER;
  }
  static void set_GATHERSCRIPT() {
    mode = GATHERSCRIPT;
  }
  static void set_FINISH() {
    mode = FINISH;
  }
  static void add_cpparg(string_t<`H> s) {
    cppargs = new List(new s,cppargs);
  }
  static bool badparse = false;
  static void unsupported_option(string_t<`H> s) {
    fprintf(stderr,"Unsupported option %s\n", s);
    badparse = true;
  }

  using Arg;

  /********************** Main *********************/
  extern "C" void GC_blacklist_warn_clear();
  int main(int argc, const char ?`H?`H argv) {
    GC_blacklist_warn_clear();

    Arg::speclist_t<`H,`H> options =
      list(new $("-d",false," <file>",
                 new String_spec(set_output_dir),
                 "Set the output directory to <file>"),
           new $("-gather",false,"",
                 new Unit_spec(set_GATHER),
                 "Gather C library info but don't produce Cyclone headers"),
           new $("-gatherscript",false,"",
                 new Unit_spec(set_GATHERSCRIPT),
                 "Produce a script to gather C library info"),
           new $("-finish",false,"",
                 new Unit_spec(set_FINISH),
                 "Produce Cyclone headers from pre-gathered C library info"),
           new $("-setjmp",false,"",
                 new Set_spec(&do_setjmp),
                 "Produce the jmp_buf and setjmp declarations"
                 " on the standard output, for use by the Cyclone"
                 " compiler special file cyc_setjmp.h.  Cannot be"
                 " used with -gather, -gatherscript, or specfiles."),
      	   new $("-b",false," <machine>",
                 new String_spec(Specsfile::set_target_arch),
                 "Set the target machine for compilation to <machine>"),
           new $("-B",true,"<file>",
                 new Flag_spec(Specsfile::add_cyclone_exec_path),
                 "Add to the list of directories to search for compiler files"),
           new $("-v",false,"",
                 new Set_spec(&verbose),
                 "Verbose operation"),
           new $("-",true,"", /* pass all other - flags to cpp */
                 new Flag_spec(add_cpparg),
                 "")
           );
    // Process the -b and -B arguments
    let otherargs = Specsfile::parse_b(options, add_spec_file, no_other, "Options:", argv);
    // Process remaining options
    Arg::current = 0;
    Arg::parse(options, add_spec_file, no_other, "Options:", otherargs);
    if (badparse
        || (!do_setjmp && spec_files == NULL)
        || (do_setjmp && spec_files != NULL)
        || (do_setjmp && mode == GATHER)
        || (do_setjmp && mode == GATHERSCRIPT)) {
      Arg::usage(options,
                 "Usage: buildlib [options] specfile1 specfile2 ...\n"
                 "Options:");
      return 1;
    }
    // Read the specs file and get the value for the C compiler and C flags
    // NB: unlike cyclone.cyc we can do this after reading the otherargs,
    // since we don't currently look in the cycspecs file for default arguments
    // to buildlib.  This means that verbose will be set properly here.
    let specs_file = Specsfile::find_in_arch_path("cycspecs");
    if (verbose) fprintf(stderr,"Reading from specs file %s\n",specs_file);
    let specs = Specsfile::read_specs(specs_file);
    target_cflags = Specsfile::get_spec(specs,"cyclone_target_cflags");
    if (verbose) fprintf(stderr,"Target cflags are %s\n",target_cflags);
    cyclone_cc = Specsfile::get_spec(specs,"cyclone_cc");
    if (!cyclone_cc) cyclone_cc = "gcc";
    if (verbose) fprintf(stderr,"C compiler is %s\n",cyclone_cc);

    if (mode == GATHERSCRIPT) {
      if (verbose)
        fprintf(stderr,"Creating BUILDLIB.sh\n");
      script_file = fopen("BUILDLIB.sh","w");
      if (!script_file) {
        fprintf(stderr,"Could not create file BUILDLIB.sh\n");
        exit(1);
      }
      prscript("#!/bin/sh\n");
      prscript("GCC=\"gcc\"\n");
    }

    /* Make sure the directory where the output files will be placed exists */
    if (force_directory_prefixes(output_dir) || force_directory(output_dir)) {
      fprintf(stderr,"Error: could not create directory %s\n",output_dir);
      return 1;
    }
    if (verbose)
      fprintf(stderr,"Output directory is %s\n",output_dir);

    if (mode == GATHERSCRIPT) {
      prscript("cd %s\n",output_dir);
      prscript("echo | $GCC %s -E -dM - -o INITMACROS.h\n",
               target_cflags);
    }

    if (!gathering()) {
      /* Create an empty log file -- most importantly, any previous log
         file will be truncated */
      log_file = fopen((const char @)(Filename::concat(output_dir,"BUILDLIB.LOG")),"w");
      if (!log_file) {
        fprintf(stderr,"Error: could not create log file in directory %s\n",output_dir);
        return 1;
      }

      if (!do_setjmp) {
        /* Create an empty cstubs.cyc file */
        cstubs_file = fopen((const char @)(Filename::concat(output_dir,"cstubs.c")),"w");
        if (!cstubs_file) {
          fprintf(stderr,"Error: could not create cstubs.c in directory %s\n",output_dir);
          return 1;
        }

        /* Create a cycstubs.cyc file with the standard prologue */
        cycstubs_file = fopen((const char @)(Filename::concat(output_dir,"cycstubs.cyc")),"w");
        if (!cycstubs_file) {
          fprintf(stderr,
                  "Error: could not create cycstubs.c in directory %s\n",
                  output_dir);
          return 1;
        }
        fprintf((FILE@)cycstubs_file,
                "#include <core.h>\n"
                "using Core;\n\n");
      }
    }


    const char @outdir = (const char @)output_dir;
    if (do_setjmp && process_setjmp(outdir)) {
      return 1;
    }
    else {
      /* Main loop -- process each spec file */
      for (; spec_files != NULL; spec_files = spec_files->tl) {
        if (process_specfile(spec_files->hd,outdir)) {
          fprintf(stderr,"FATAL ERROR -- QUIT!\n");
          exit(1);
        }
      }
    }

    if (mode == GATHERSCRIPT) {
      fclose((FILE@)script_file);
    }
    else if (!gathering()) {
      fclose((FILE@)log_file);
      if (!do_setjmp) {
        fclose((FILE@)cstubs_file);
        fclose((FILE@)cycstubs_file);
      }
    }

    return 0;
  }
