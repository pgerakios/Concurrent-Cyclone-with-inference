#line 19 "/home/pgerakios/reglock/branches/cyclone/0.8.3/lib/lineno.cyl"
 
#include <lexing.h>
#include <string.h>
#include <lineno.h>

namespace Lineno;

enum token_val {
  NEWLINE,
  LINEDEF,
  END
};

using Lexing {

const int lex_base[] = {0,1,-2,2,6,-3,16,7,-1,8};
const int lex_backtrk[] = {-1,-1,-1,1,-1,-1,-1,-1,-1,0};
const int lex_default[] = {1,1,0,-1,1,0,7,7,0,-1};
const int lex_trans[] = {0,0,0,0,0,0,0,0,0,0,2,2,2,3,3,4,2,8,8,3,9,0,0,0,0,0,8,0,0,9,0,0,0,0,0,4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,5,5,0,0,0,0,0,0,0,0,5};
const int lex_check[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,3,0,1,4,4,7,9,4,7,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,0,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,4,4,4,4,4,4,4,4,6,6,6,6,6,6,6,6,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,-1,-1,-1,-1,4,7,-1,-1,-1,-1,-1,-1,-1,-1,6};
     int lex_engine(int start_state, Lexbuf<`a> lbuf) {

       int state, base, backtrk;
       int c;
       state = start_state;

       if (state >= 0) {
	 lbuf->lex_last_pos = lbuf->lex_start_pos = lbuf->lex_curr_pos;
	 lbuf->lex_last_action = -1;
       } else {
	 state = -state-1;
       }
       while (true) {
	 base = lex_base[state];
	 if (base < 0) return -base-1;
	 backtrk = lex_backtrk[state];
	 if (backtrk >= 0) {
	   lbuf->lex_last_pos    = lbuf->lex_curr_pos;
	   lbuf->lex_last_action = backtrk;
	 }
	 if (lbuf->lex_curr_pos >= lbuf->lex_buffer_len) {
	   if (!lbuf->lex_eof_reached)
	     return -state-1;
	   else
	     c = 256;
	 } else {
	   c = (int) (lbuf->lex_buffer[lbuf->lex_curr_pos++]);
	   if (c==EOF) c=256;
	 }
	 if (lex_check[base+c]==state)
	   state = lex_trans[base+c];
	 else
	   state = lex_default[state];
	 if (state < 0) {
	   lbuf->lex_curr_pos = lbuf->lex_last_pos;
	   if (lbuf->lex_last_action == -1)
	     throw new Error("empty token");
	   else {
	     return lbuf->lex_last_action;
	   }
	 } else {
	   if (c == 256) lbuf->lex_eof_reached = false;
	 }
       }
  }
enum token_val token_rec(Lexbuf<`a> lexbuf, int lexstate) {
  lexstate = lex_engine(lexstate,lexbuf);
  switch (lexstate) {

case 0: 
#line 49 "/home/pgerakios/reglock/branches/cyclone/0.8.3/lib/lineno.cyl"
                                                      return LINEDEF; 
case 1: 
#line 50 "/home/pgerakios/reglock/branches/cyclone/0.8.3/lib/lineno.cyl"
                               return NEWLINE; 
case 2: 
#line 51 "/home/pgerakios/reglock/branches/cyclone/0.8.3/lib/lineno.cyl"
                               return END;  default:
   lexbuf->refill_buff(lexbuf);
   return token_rec(lexbuf, lexstate);
  }
 throw new Error("some action didn't return!");
}
enum token_val token(Lexbuf<`a> lexbuf) { return token_rec(lexbuf,0); }

}
#line 53 "/home/pgerakios/reglock/branches/cyclone/0.8.3/lib/lineno.cyl"
 

using Core;
using Lexing;

struct Pos {
  string_t logical_file;
  mstring_t line;
  int    line_no;
  int    col;
};

static $(mstring_t,int)* parse_linedef(mstring_t line) {
  try {
    int i = 0;
    while (i < numelts(line) && (line[i] < '0' || line[i] > '9')) ++i;
    int j = i;
    while (j < numelts(line) && line[j] >= '0' && line[j] <= '9') ++j;
    if (i == numelts(line)) return NULL; // if there's no number
    int number = 0;
    if (sscanf(substring(line,i,j-i),"%d",&number) != 1)
      return NULL;
    while (j < numelts(line) && line[j] != '"') ++j;
    int k = ++j;
    while (k < numelts(line) && line[k] != '"') ++k;
    if (j == numelts(line) || k == numelts(line)) return NULL; // if no name
    mstring_t fname = substring(line,j,k-j);
    return new $(fname,number);
  } catch { default: return NULL; }
}

int place_cmp($(int,pos_t)@ place1, $(int,pos_t)@ place2) {
  return intcmp((*place1)[0],(*place2)[0]);
}

// mutates second argument's elements
void poss_of_abss(string_t filename, List::list_t<$(int,pos_t)@,`H> places) {
  places = List::merge_sort(place_cmp, places);
  FILE @f = file_open(filename, "r");
  try {
    Lexbuf<Function_lexbuf_state<FILE@>> lbuf = from_file(f);
    let source_file = filename;
    let line        = 1;
    mstring_t this_line;
    let eol;
    let next;

    while (places != NULL) {
      while (true) {
	next      = token(lbuf);
	eol       = lexeme_end(lbuf);
        /* NOTE: eol is the index of the char AFTER the lexeme */
	this_line = lexeme(lbuf); // FIX: expensive string copy

	if (next == END || eol > (*places->hd)[0]) 
	  break;

        if (next == NEWLINE) ++line;
        else {
	  $(mstring_t,int)* fno = parse_linedef(this_line);
	  if (fno == NULL) {
	    ++line;
            // Commented out because it produces spurious warnings in cycdoc.
	    // fprintf(stderr, "Unknown directive: %s\n", this_line);
	  } else {
	    source_file = (*fno)[0];
	    line        = (*fno)[1];
	  }
        }
      }
      while (places != NULL && (next == END || eol > (*places->hd)[0])) {
	let p = (*places->hd)[1];
	p->logical_file = strdup(source_file);
	p->line         = this_line;
	p->line_no      = line;
	p->col          = strlen(this_line)-(eol-(*places->hd)[0]);
        if (p->col < 0) p->col = 0;
	places = places->tl;
      }
      ++line;
    }
  } catch { case y: file_close(f); throw (y); }
  file_close(f);
  return;
}

pos_t pos_of_abs(string_t filename, int abs) {
  pos_t ans = new Pos("",new_string(0),0,0);
  poss_of_abss(filename, new List::List(new $(abs,ans),NULL));
  return ans;
}

