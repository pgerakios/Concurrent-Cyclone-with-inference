
#include <core.h>
#include <stdio.h> 
#include <stdlib.h> 

namespace Core {
  int tid() @nothrow @re_entrant;
  void nsleep(long) @nothrow @re_entrant;
  void flush() @nothrow @re_entrant;
  void print_xtree(region_t<`r::X>) @nothrow @re_entrant;
}

#define fl Core::flush 
#define nsleep Core::nsleep
#define MONITOR_TIME 500000000 // 0.1 sec


void foo( region_t<`r0::X> h, int @`r::X ref,int mode) 
 @xrgn @nothrow @re_entrant
{ 
//  Core::print_xtree(h);
  int i;
  let h0 = h;
   for(i=0;i<1000;i++) {
      cap(h,0,0,1);
      fprintf(stderr,"\n[%d] Acquiring readlock",Core::tid());
      fl();
      fprintf(stderr,"\n[%d] Reading ref : %d", 
              Core::tid(), *ref);
      fl();
      nsleep(MONITOR_TIME);
      fprintf(stderr,"\n[%d] Releasing readlock",Core::tid());
      cap(h,0,0,-1);
      nsleep(MONITOR_TIME);
     fl();
   }
  cap(h0,-1,0,0);
}
void foo2(region_t<`r::X> h, int @`r0::X ref ) @xrgn {
int i;
   for(i=0;i<1000;i++) {
      cap(h,0,1,0);
      fprintf(stderr,"\n[%d] Acquired writelock",Core::tid());
      fl();
      let tmp = *ref;
      *ref = i;
      fprintf(stderr,"\n[%d] Writing ref : %d --> %d", 
              Core::tid(),tmp, *ref);
      fl();
      nsleep(MONITOR_TIME);
      fprintf(stderr,"\n[%d] Releasing writelock",Core::tid());
      cap(h,0,-1,0);
      nsleep(MONITOR_TIME);
      fl();
   }
}
// TEST SUB-REGIONS
int main(int argc, char *@fat *@fat argv) {

 region h @ Core::heap_region;
 region h1 @ h;
 try{
   
       let ref = rnew(h1) 30;
       fprintf(stderr,"\n[%d] Before SPAWN",Core::tid());
       int i;
       *ref = 25;
       cap(h,0,-1,0);
       cap(h1,0,-1,0);
       for(i= 0 ; i < 2 ; i++ ) {
          cap(h1,1,0,0);
          spawn ($(h1,1,0,0)) foo(h1,ref,0);    
       }
      foo2(h,ref);

  } catch {
      case &Core::Failure(s):
         printf("\nHello world !");
         break;
  }
 cap(h,-1,0,0);
 
  return 130;
}
